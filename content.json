{"meta":{"title":"a.d","subtitle":"永远热爱","description":"爱你所爱，行你所行","author":"a.d","url":"http://blog.aiheadn.cn","root":"/"},"pages":[{"title":"分类","date":"2023-01-02T09:52:42.000Z","updated":"2023-01-02T09:54:35.997Z","comments":true,"path":"categories/index.html","permalink":"http://blog.aiheadn.cn/categories/index.html","excerpt":"","text":""},{"title":"a.d 的好朋友们","date":"2023-01-02T09:55:46.000Z","updated":"2023-01-02T09:57:00.408Z","comments":true,"path":"link/index.html","permalink":"http://blog.aiheadn.cn/link/index.html","excerpt":"","text":""},{"title":"关于我","date":"2023-01-03T04:24:25.000Z","updated":"2023-03-08T08:15:23.678Z","comments":true,"path":"about/index.html","permalink":"http://blog.aiheadn.cn/about/index.html","excerpt":"","text":"介绍：你好呀 我是a.d Hi This is a.d 01年的狮子座，计算机科学与技术💻 学生 本科在读 爱你所爱，行你所行 欢迎来到这个页面 爱好： 小说 摄影 IT 计算机 编程 平面设计 PS 编程语言： 语言 e Java html5+css3 javascript 技术栈： 技术栈 Spring Vue2 联系我： QQ ： 2585570153 哔哩哔哩： UID638159906"},{"title":"标签","date":"2023-01-02T09:48:37.000Z","updated":"2023-01-02T09:54:47.706Z","comments":true,"path":"tags/index.html","permalink":"http://blog.aiheadn.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基于后端spring学习总结","slug":"基于后端spring学习总结","date":"2023-03-08T02:45:59.000Z","updated":"2023-03-08T08:07:55.018Z","comments":true,"path":"archives/41256f59.html","link":"","permalink":"http://blog.aiheadn.cn/archives/41256f59.html","excerpt":"以下笔记转载自githubIOC 和 DI 的概述IOC(Inversion of Controll)思想是反转资源获取的方向，传统的资源查找方式要求组件向容器发起请求查找资源。作为回应，容器适时的返回资源。而应用了IOC之后，则是容器主动的将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接收资源 DI(Dependency Injection)是IOC的另一种表述方式，即组件以一些预先定义好的方式(如：getter方法)来接收来自容器的资源注入","text":"以下笔记转载自githubIOC 和 DI 的概述IOC(Inversion of Controll)思想是反转资源获取的方向，传统的资源查找方式要求组件向容器发起请求查找资源。作为回应，容器适时的返回资源。而应用了IOC之后，则是容器主动的将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接收资源 DI(Dependency Injection)是IOC的另一种表述方式，即组件以一些预先定义好的方式(如：getter方法)来接收来自容器的资源注入 Spring配置在SpringIOC容器读取bean配置创建bean实例之前，必须对它进行实例化。只有在容器实例化后，才可以从IOC容器里获取bean实例并使用 Spring提供了两种类型的IOC容器实现 BeanFactory：IOC容器的基本实现，在调用getBean()方法时才会实例化对象 ApplicationContext：提供了更多的高级特性，在加载配置文件后就会实例化对象。是BeanFactory的子接口 BeanFactory是Spring框架的基础设施，面向Spring本身 ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都直接使用ApplicationContext而非底层的BeanFactory 无论使用何种方式，配置文件时都是相同的 12345&lt;!-- 配置bean --&gt;&lt;!-- class: bean的全类名，通过反射的方式在IOC容器中创建bean，所以要求bean中必须有无参构造器 --&gt;&lt;bean id=&quot;people&quot; class=&quot;learningspring.ioc.examples.People&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Chen&quot;/&gt;&lt;/bean&gt; 123456789101112131415161718192021public class People &#123; private String name; public People() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;People&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 12345678910@Testpublic void test()&#123; // 创建IOC容器 ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;F:\\\\Projects\\\\IdeaProjects\\\\LearningSpring\\\\src\\\\main\\\\java\\\\learningspring\\\\ioc\\\\examples\\\\applicationContext.xml&quot;); // 从IOC容器中获取bean实例 People people = (People) ctx.getBean(&quot;people&quot;); System.out.println(people);&#125; ApplicationContextApplicationContext有两个实现类： ClassPathXmlApplicationContext：加载类路径里的配置文件 FileSystemXmlApplicationContext：加载文件系统里的配置文件 Bean的相关配置bean标签的id和name的配置 id：使用了约束中的唯一约束。不能有特殊字符 name：没有使用约束中的唯一约束（理论上可以重复，但是实际开发中不能出现）。可以有特殊字符 bean的生命周期的配置 init-method：bean被初始化的时候执行的方法 destroy-method：bean被销毁的时候执行的方法，前提是bean是单例的，工厂关闭 bean的作用范围的配置 scope：bean的作用范围 singleton：单例模式，默认的作用域。 prototype：多例模式。 request：应用在Web项目中，Spring创建这个类后，将这个类存入到request范围中。 session：应用在Web项目中，Spring创建这个类后，将这个类存入到session范围中。 globalsession：应用在Web项目中，必须在porlet环境下使用。但是如果没有这种环境，相当于session。 Spring的Bean管理配置Spring的Bean的实例化方式无参构造方式（默认）123456789101112131415161718192021222324252627282930313233343536/** * //TODO * * @author Chen Rui * @version 1.0 **/public class Dog &#123; private String name; private Integer length; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getLength() &#123; return length; &#125; public void setLength(Integer length) &#123; this.length = length; &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, length=&quot; + length + &#x27;&#125;&#x27;; &#125;&#125; 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- Spring Bean的实例化方式--&gt; &lt;!-- 无参构造的方式 --&gt; &lt;bean id=&quot;dog&quot; class=&quot;learningspring.ioc.examples.demo3.Dog&quot;/&gt;&lt;/beans&gt; 静态工厂实例化方式12345678910111213141516171819202122232425/** * * @author Chen Rui * @version 1.0 **/public class Car &#123; private String name; private Double price; public Car() &#123; &#125; public Car(String name, Double price) &#123; this.name = name; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &#x27;&#125;&#x27;; &#125;&#125; 12345678910111213package learningspring.ioc.examples.demo3;/** * * @author Chen Rui * @version 1.0 **/public class CarFactory &#123; public static Car createCar()&#123; return new Car(); &#125;&#125; 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- Spring Bean的实例化方式--&gt; &lt;!-- 静态工厂的方式 --&gt; &lt;bean id=&quot;car&quot; class=&quot;learningspring.ioc.examples.demo3.CarFactory&quot; factory-method=&quot;createCar&quot;/&gt;&lt;/beans&gt; 实例工厂实例化方式123456789101112131415161718192021222324252627282930313233343536/** * //TODO * * @author Chen Rui * @version 1.0 **/public class Dog &#123; private String name; private Integer length; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getLength() &#123; return length; &#125; public void setLength(Integer length) &#123; this.length = length; &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, length=&quot; + length + &#x27;&#125;&#x27;; &#125;&#125; 123456789101112/** * //TODO * * @author Chen Rui * @version 1.0 **/public class DogFactory &#123; public Dog createDog()&#123; return new Dog(); &#125;&#125; 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- Spring Bean的实例化方式--&gt; &lt;!-- 实例工厂的方式 --&gt; &lt;bean id=&quot;dogFactory&quot; class=&quot;learningspring.ioc.examples.demo3.DogFactory&quot;/&gt; &lt;bean id=&quot;dog2&quot; factory-bean=&quot;dogFactory&quot; factory-method=&quot;createDog&quot;/&gt;&lt;/beans&gt; Spring的属性注入方式构造方法方式的属性注入12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--构造方法方式的属性注入--&gt; &lt;bean id=&quot;car&quot; class=&quot;learningspring.ioc.examples.demo3.Car&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;BWM&quot;/&gt; &lt;constructor-arg name=&quot;price&quot; value=&quot;800000&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; Set方法方式的属性注入1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--Set方法方式的属性注入--&gt; &lt;bean id=&quot;dog&quot; class=&quot;learningspring.ioc.examples.demo3.Dog&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Golden&quot;/&gt; &lt;property name=&quot;length&quot; value=&quot;100&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 为Bean注入引用类型的数据123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--构造方法方式的属性注入--&gt; &lt;bean id=&quot;car&quot; class=&quot;learningspring.ioc.examples.demo3.Car&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;BWM&quot;/&gt; &lt;constructor-arg name=&quot;price&quot; value=&quot;800000&quot;/&gt; &lt;/bean&gt; &lt;!--Set方法方式的属性注入--&gt; &lt;bean id=&quot;dog&quot; class=&quot;learningspring.ioc.examples.demo3.Dog&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Golden&quot;/&gt; &lt;property name=&quot;length&quot; value=&quot;100&quot;/&gt; &lt;/bean&gt; &lt;!--为Bean注入对象属性--&gt; &lt;!--构造方法方式一样可行--&gt; &lt;bean id=&quot;employee&quot; class=&quot;learningspring.ioc.examples.demo3.Employee&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Chen&quot;/&gt; &lt;property name=&quot;car&quot; ref=&quot;car&quot;/&gt; &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; P名称空间的属性注入（Spring2.5） 通过引入p名称空间完成属性注入 普通属性：p:属性名&#x3D;“值” 对象属性：p:属性名-ref&#x3D;“值” 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--P名称空间的属性注入--&gt; &lt;bean id=&quot;cat&quot; class=&quot;learningspring.ioc.examples.demo3.Cat&quot; p:name=&quot;Orange&quot; p:length=&quot;100&quot;/&gt; &lt;!--为Bean注入对象属性--&gt; &lt;bean id=&quot;employee&quot; class=&quot;learningspring.ioc.examples.demo3.Employee&quot; p:cat-ref=&quot;cat&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Chen&quot;/&gt; &lt;property name=&quot;car&quot; ref=&quot;car&quot;/&gt; &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; SpEL方式的属性注入（Spring3）SpEL：Spring Expresssion Language 的表达式语言 语法：#{表达式} 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--SpEL表达式注入--&gt; &lt;bean id=&quot;cat2&quot; class=&quot;learningspring.ioc.examples.demo4.Cat&quot;&gt; &lt;!--字符串要加单引号--&gt; &lt;!--也可以通过#&#123;beanName.属性名或方法名&#125;来通过其他bean的属性或者方法来注入--&gt; &lt;property name=&quot;name&quot; value=&quot;#&#123;&#x27;Orange&#x27;&#125;&quot;/&gt; &lt;property name=&quot;length&quot; value=&quot;#&#123;101&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 注入集合类型的数据12345678910111213141516171819202122232425262728293031323334353637383940/** * 注入集合类型的数据测试 * * @author Chen Rui * @version 1.0 **/public class CollectionBean &#123; private String[] strs; private List&lt;String&gt; list; private Set&lt;String&gt; set; private Map&lt;String, String&gt; map; public void setStrs(String[] strs) &#123; this.strs = strs; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void setSet(Set&lt;String&gt; set) &#123; this.set = set; &#125; public void setMap(Map&lt;String, String&gt; map) &#123; this.map = map; &#125; @Override public String toString() &#123; return &quot;CollectionBean&#123;&quot; + &quot;strs=&quot; + Arrays.toString(strs) + &quot;, list=&quot; + list + &quot;, set=&quot; + set + &quot;, map=&quot; + map + &#x27;&#125;&#x27;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--Spring的集合属性的注入--&gt; &lt;!--注入数组类型--&gt; &lt;bean id=&quot;collectionBean&quot; class=&quot;learningspring.ioc.examples.demo4.CollectionBean&quot;&gt; &lt;!-- 注入数组类型 --&gt; &lt;property name=&quot;strs&quot;&gt; &lt;list&gt; &lt;value&gt;Tom&lt;/value&gt; &lt;value&gt;Jack&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入List集合 --&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;Lucy&lt;/value&gt; &lt;value&gt;Lily&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入Set集合 --&gt; &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 注入Map集合 --&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;a&quot; value=&quot;1&quot;/&gt; &lt;entry key=&quot;b&quot; value=&quot;2&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Spring分模块开发的配置 加载配置文件时，直接加载多个配置文件 1ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;, &quot;applicationContext2.xml&quot;); 在一个配置文件中引入多个配置文件 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--引入配置文件--&gt; &lt;import resource=&quot;applicationContext2.xml&quot;/&gt; &lt;/beans&gt; Spring开发中的常用注解@Component该注解在类上使用，使用该注解就相当于在配置文件中配置了一个Bean，例如： 1234567@Component(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(&quot;UserDaoImpl.save&quot;); &#125;&#125; 相当于以下内容： 1&lt;bean id=&quot;userDao&quot; class=&quot;learningspring.ioc.examplesannotation.demo1.UserDaoImpl&quot;&gt;&lt;/bean&gt; 该注解有3个衍生注解： @Controller：修饰Web 层类 @Service：修饰Service层类 @Repository：修饰Dao层类 @Value该注解用于给属性注入值，有2种用法 如果有set方法，则需要将该注解添加到set方法上 如果没有set方法，则需要将该注解添加到属性上 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Value 注解用于属性注入 * 当类有提供set方法时添加在set方法上 * 如果没有，则添加到属性上 * * @author Chen Rui * @version 1.0 **/@Component(&quot;dog&quot;)public class Dog &#123; private String name; @Value(&quot;100&quot;) // 注入属性值 private Double length; public Dog() &#123; &#125; public Dog(String name, Double length) &#123; this.name = name; this.length = length; &#125; public String getName() &#123; return name; &#125; @Value(&quot;Golden&quot;) // 注入属性值 public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, length=&quot; + length + &#x27;&#125;&#x27;; &#125;&#125; @Autowired@Value 通常用于普通属性的注入。 @Autowired 通常用于为对象类型的属性注入值，但是按照类型完成属性注入 习惯是按照名称完成属性注入，所以必须让@Autowired注解和@Qualifier注解一同使用。 （如果没有@Qualifier注解，修改以下例子中@Repository注解的值，也能编译成功） 12345678910111213@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService &#123; @Autowired @Qualifier(&quot;userDao&quot;) private UserDao userDao; @Override public void save() &#123; System.out.println(&quot;UserServiceImpl.save&quot;); userDao.save(); &#125;&#125; 1234567@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(&quot;UserDaoImpl.save&quot;); &#125;&#125; @Resource该注解也可以用于属性注入，通常情况下使用**@Resource注解，默认按照名称**完成属性注入。 该注解由J2EE提供，需要导入包javax.annotation.Resource。 @Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。 12345678910111213/** * UserController * * @author Chen Rui * @version 1.0 **/@Controller(&quot;userController&quot;)public class UserController &#123; @Resource(name = &quot;userService&quot;) private UserService userService; &#125; 1234567891011121314151617181920/** * UserService实现类 * * @author Chen Rui * @version 1.0 **/@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService &#123; @Resource(name = &quot;userDao&quot;) private UserDao userDao; @Override public void save() &#123; System.out.println(&quot;UserServiceImpl.save&quot;); userDao.save(); &#125;&#125; 1234567891011121314/** * UserDao实现类 * @author Chen Rui * @version 1.0 **/@Component(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(&quot;UserDaoImpl.save&quot;); &#125;&#125; @PostConstruct 和 @PreDestroy@PostConstruct和@PreDestroy注解，前者为Bean生命周期相关的注解，在配置文件中，使用到了init-method参数来配置Bean初始化之前要执行的方法，该注解也是同样的作用。将该注解添加到想在初始化之前执行的目标方法上，就可以实现该功能，而后者则是Bean生命周期中destroy-method目标方法，使用该注解在指定方法上，即可实现在Bean销毁之前执行该方法。 123456789101112131415161718192021222324/** * UserDao实现类 * @author Chen Rui * @version 1.0 **/@Component(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123; @PostConstruct public void init()&#123; System.out.println(&quot;UserDaoImpl.init&quot;); &#125; @Override public void save() &#123; System.out.println(&quot;UserDaoImpl.save&quot;); &#125; @PreDestroy public void destroy()&#123; System.out.println(&quot;UserDaoImpl.destroy&quot;); &#125;&#125; @ScopeBean的作用范围的注解，默认为singleton（单例） 可选值： singleton prototype request session globalsession 12345678910111213141516171819202122232425/** * UserDao实现类 * @author Chen Rui * @version 1.0 **/@Component(&quot;userDao&quot;)@Scope // 默认为singletonpublic class UserDaoImpl implements UserDao &#123; @PostConstruct public void init()&#123; System.out.println(&quot;UserDaoImpl.init&quot;); &#125; @Override public void save() &#123; System.out.println(&quot;UserDaoImpl.save&quot;); &#125; @PreDestroy public void destroy()&#123; System.out.println(&quot;UserDaoImpl.destroy&quot;); &#125;&#125; 基于XML配置和基于注解配置的对比 基于XML的配置 基于注解的配置 Bean的定义 &lt;bean id&#x3D;”Bean的id” class&#x3D;”类的全路径”&#x2F;&gt; @Component或衍生注解@Controller，@Service和@Repository Bean的名称 通过id或name指定 @Component(“Bean的id”) Bean的属性注入 &lt;property&gt;或者通过p命名空间 通过注解@Autowired 按类型注入通过@Qualifier按名称注入 Bean的生命周期 init-method指定Bean初始化前执行的方法，destroy-method指定Bean销毁前执行的方法 @PostConstruct 对应于int-method@PreDestroy 对应于destroy-method Bean的作用域 在bean标签中配置scope属性 @Scope, 默认是singleton配置多例可以在目标类上使用@Scope(“prototype”) 使用场景 Bean来自第三方，可以使用在任何场景 Bean的实现类由自己维护 XML可以适用于任何场景，就算Bean来自第三方也可以适用XML方式来管理。而注解方式就无法在此场景下使用，注解方式可以让开发的过程更加方便，但前提是Bean由自己维护，这样才能在源码中添加注解。 所以可以使用两者混合的方式来开发项目，使用XML配置文件来管理Bean，使用注解来进行属性注入 Spring AOPAOP的概述即面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP的案例（应用场景）背景：某项目已经写好了保存到数据库的方法。假设现在需要添加一个新的功能，例如权限校验，在保存到数据库之前要对用户权限进行校验。 123456public class UserDaoImpl implements UserDao &#123; @Override public void save()&#123; ... &#125;&#125; 现在需要多加一个需求，在用户将数据保存到数据库之前，进行权限校验。 此时通常就会在该方法中添加一个方法来进行权限校验然后在save方法中调用。 1234567891011public class UserDaoImpl implements UserDao &#123; @Override public void save()&#123; checkPri(); // 保存到数据库 &#125; private void checkPri()&#123; // 权限校验 &#125;&#125; 用这样的方法来实现，弊端就是只能在这一个类中使用，通常一个项目中有许多的方法都可能需要执行权限校验，此时就要在每个类中编写同样的代码，所以该方法并不科学。 此时就有了一个更好的方法，即纵向继承。 定义一个通用的Dao，在通用的Dao中编写权限校验的方法。 12345public class BaseDao&#123; public void checkPri()&#123; // 权限校验 &#125;&#125; 然后每一个不同的类都去继承这个类，再调用该方法 1234567public class UserDaoImpl extends BaseDao implements UserDao&#123; @Override public void save()&#123; checkPri(); // 保存到数据库 &#125;&#125; 此时就只需要维护BaseDao中的一份代码就可以，大大减轻了工作量，提高了效率。 但AOP的思想更高一步，不采用纵向继承，而采用横向抽取来取代 123456public class UserDaoImpl implements UserDao&#123; @Override public void save()&#123; // 保存到数据库 &#125;&#125; 横向抽取机制实质上就是代理机制，通过创建UserDaoImpl类的代理类，通过代理类来调用权限校验的方法。 AOP底层实现原理AOP的实现使用了动态代理技术，动态代理分为两种 JDK动态代理：只能对实现了接口的类产生代理 Cglib动态代理（类似于javassist的第三方代理技术）：对没有实现接口的类产生代理对象，即生成子类对象。 JDK动态代理JDK动态代理案例该案例实现一个计算器的日志功能 首先创建一个接口Calculator 12345678910111213141516171819202122232425262728293031323334353637383940/** * 计算器接口 * * @author Chen Rui * @version 1.0 **/public interface Calculator &#123; /** * 加法 * @param a 实数 * @param b 实数 * @return 相加结果 */ int add(int a, int b); /** * 减法 * @param a 实数,被减数 * @param b 实数,减数 * @return 相减结果 */ int sub(int a, int b); /** * 乘法 * @param a 实数 * @param b 实数 * @return 相乘结果 */ int mul(int a, int b); /** * 除法 * @param a 实数,被除数 * @param b 实数,除数 * @return 相除结果 */ int div(int a, int b);&#125; 接着创建一个类CalculatorImpl来实现该接口并重写方法 123456789101112131415161718192021222324252627282930313233/** * 计算器实现类 * * @author Chen Rui * @version 1.0 **/public class CalculatorImpl implements Calculator &#123; @Override public int add(int a, int b) &#123; return a + b; &#125; @Override public int sub(int a, int b) &#123; return a - b; &#125; @Override public int mul(int a, int b) &#123; return a * b; &#125; @Override public int div(int a, int b) &#123; if (b == 0)&#123; System.out.println(&quot;除数不能为0&quot;); return 0; &#125; return a / b; &#125;&#125; 在测试类中测试该计算器代码 1234567891011121314151617181920/** * @author Chen Rui * @version 1.0 **/public class AppTest &#123; @Test public void test() &#123; Calculator target = new CalculatorImpl(); int a = 10; int b = 10; System.out.println(&quot;res --&gt; &quot; + target.add(a, b)); System.out.println(&quot;res --&gt; &quot; + target.mul(a, b)); System.out.println(&quot;res --&gt; &quot; + target.sub(a, b)); System.out.println(&quot;res --&gt; &quot; + target.div(a, b)); &#125;&#125; 此时控制台的输出结果为： 1234res --&gt; 20res --&gt; 100res --&gt; 0res --&gt; 1 现在为该计算器增加打印日志的功能 创建一个计算器的代理类CalculatorLoggingProxy，在类中首先定义被代理的目标对象target，并通过构造函数进行赋值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;import java.util.Date;/** * 计算器代理类 * 实现扩展打印日志功能 * * @author Chen Rui * @version 1.0 **/public class CalculatorProxy &#123; /** * 被代理的对象 */ private Calculator target; public CalculatorProxy(Calculator target) &#123; this.target = target; &#125; public Calculator createProxy()&#123; Calculator proxy; ClassLoader classLoader = target.getClass().getClassLoader(); Class[] interfaces = new Class[]&#123;Calculator.class&#125;; InvocationHandler handler = new InvocationHandler() &#123; /** * @param proxy 正在返回的代理对象，一般在invoke方法中都不使用该对象 * 如果使用该对象，则会引发栈内存溢出。因为会循环调用invoke方法。 * @param method 正在被调用的方法 * @param args 调用方式时传入的参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 获取方法名 String methodName = method.getName(); // 输出日志逻辑 System.out.println(new Date() + &quot;: The method &quot; + methodName + &quot; begins with &quot; + Arrays.asList(args)); // 执行方法 Object result = method.invoke(target, args); // 输出日志逻辑 System.out.println(new Date() + &quot;: The method &quot; + methodName + &quot; ends with &quot; + result); return result; &#125; &#125;; proxy = (Calculator) Proxy.newProxyInstance(classLoader,interfaces,handler); return proxy; &#125;&#125; 此时重新编写测试方法 12345678910111213141516171819202122/** * @author Chen Rui * @version 1.0 **/public class AppTest &#123; @Test public void test() &#123; Calculator target = new CalculatorImpl(); // 创建代理对象 Calculator proxy = new CalculatorProxy(target).createProxy(); int a = 10; int b = 10; System.out.println(&quot;res --&gt; &quot; + proxy.add(a, b)); System.out.println(&quot;res --&gt; &quot; + proxy.mul(a, b)); System.out.println(&quot;res --&gt; &quot; + proxy.sub(a, b)); System.out.println(&quot;res --&gt; &quot; + proxy.div(a, b)); &#125;&#125; 到此就完成了在不改变CalculatorImpl类的源代码的情况下，实现对计算器的功能增加，实现了日志打印的功能。此时控制台的打印内容为 123456789101112Sun Mar 17 20:36:26 CST 2019: The method add begins with [10, 10]Sun Mar 17 20:36:26 CST 2019: The method add ends with 20res --&gt; 20Sun Mar 17 20:36:26 CST 2019: The method mul begins with [10, 10]Sun Mar 17 20:36:26 CST 2019: The method mul ends with 100res --&gt; 100Sun Mar 17 20:36:26 CST 2019: The method sub begins with [10, 10]Sun Mar 17 20:36:26 CST 2019: The method sub ends with 0res --&gt; 0Sun Mar 17 20:36:26 CST 2019: The method div begins with [10, 10]Sun Mar 17 20:36:26 CST 2019: The method div ends with 1res --&gt; 1 Cglib动态代理Cglib动态代理案例同样来实现一个对计算器来增加打印日志功能 首先创建计算器类Calculator 1234567891011121314151617181920212223242526272829/** * 计算器类 * * @author Chen Rui * @version 1.0 **/public class Calculator &#123; public int add(int a, int b) &#123; return a + b; &#125; public int sub(int a, int b) &#123; return a - b; &#125; public int mul(int a, int b) &#123; return a * b; &#125; public int div(int a, int b) &#123; if (b == 0)&#123; System.out.println(&quot;除数不能为0&quot;); return 0; &#125; return a / b; &#125;&#125; 此时需要导入cglib的jar包，在maven中添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 接着创建计算器的代理类CalculatorProxy并且实现MethodInterceptor接口并重写intercept方法。 在类中首先定义被代理的目标对象，并通过构造函数进行赋值。然后创建createProxy()方法返回被增强的计算器对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 计算器代理类 * * @author Chen Rui * @version 1.0 **/public class CalculatorProxy implements MethodInterceptor &#123; /** * 被代理的对象 */ private Calculator target; public CalculatorProxy(Calculator target) &#123; this.target = target; &#125; public Calculator createProxy()&#123; // 1.创建cglib的核心类对象 Enhancer enhancer = new Enhancer(); // 2.设置父类 enhancer.setSuperclass(target.getClass()); // 3.设置回调（类似于jdk动态代理中的InvocationHandler对象） enhancer.setCallback(this); // 4.创建代理对象 Calculator proxy = (Calculator) enhancer.create(); return proxy; &#125; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; // 获取方法名 String methodName = method.getName(); // 输出日志逻辑 System.out.println(new Date() + &quot;: The method &quot; + methodName + &quot; begins with &quot; + Arrays.asList(args)); // 执行方法 Object result = methodProxy.invokeSuper(proxy, args); // 输出日志逻辑 System.out.println(new Date() + &quot;: The method &quot; + methodName + &quot; ends with &quot; + result); return result; &#125;&#125; Spring中的AOP实现——AspectJAOP开发中的相关术语123456789public class UserDao&#123; public void save()&#123;&#125; public void query()&#123;&#125; public void update()&#123;&#125; public void delete()&#123;&#125;&#125; joinpoint(连接点) ： 可以被拦截到的点。save(), query(),update(),delete()方法都可以增强，这些方法就可以称为连接点。 pointcut(切入点)：真正被拦截到的点。在实际开发中，可以只对save()方法进行增强，那么save()方法就是切入点。 advice(增强)：方法层面的增强，现在可以对save()方法进行权限校验，权限校验(checkPri())的方法称为增强。 introduction(引介)：类层面的增强。 target(目标)：被增强的对象。 weaving(织入)：将增强(advice)应用到目标(target)的过程 proxy(代理)：代理对象，被增强以后的代理对象 aspect(切面)：多个增强(advice)和多个切入点(pointcut)的组合 AspectJ的XML配置案例首先创建一个接口ProductDao，在里面定义添加商品，查询商品，修改商品，删除商品方法。 1234567891011121314151617181920212223242526272829/** * ProductDao * * @author Chen Rui * @version 1.0 **/public interface ProductDao &#123; /** * 添加商品 */ void save(); /** * 删除商品 */ void delete(); /** * 修改商品 */ void modify(); /** * 查询商品 */ void query();&#125; 接着创建一个类ProductDaoImpl来实现该接口 123456789101112131415161718192021222324252627282930/** * ProductDao的实现类 * * @author Chen Rui * @version 1.0 **/public class ProductDaoImpl implements ProductDao &#123; @Override public void save() &#123; System.out.println(&quot;添加商品&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除商品&quot;); &#125; @Override public void modify() &#123; System.out.println(&quot;修改商品&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询商品&quot;); &#125; &#125; 现在目的就是给save()方法进行增强，使得在调用save()方法前进行权限校验。 要实现此功能，先创建一个增强类，或者叫切面类。里面编写要增强的功能，例如权限校验。 创建增强类ProductEnhancer 1234567891011121314/** * ProductDao的增强类(切面类) * * @author Chen Rui * @version 1.0 **/public class ProductEnhancer &#123; public void checkPri()&#123; System.out.println(&quot;【前置增强】权限校验&quot;); &#125;&#125; 然后创建配置文件aspectj-xml.xml来配置，该文件名此案例仅用于演示，实际开发中不要采取此名，依据实际需求编写。 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 配置目标对象，即被增强的对象 --&gt; &lt;bean id=&quot;productDao&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductDaoImpl&quot;/&gt; &lt;!-- 将增强类(切面类)交给Spring管理 --&gt; &lt;bean id=&quot;productEnhancer&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductEnhancer&quot;/&gt; &lt;!-- 通过对AOP的配置完成对目标对象产生代理 --&gt; &lt;aop:config&gt; &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 --&gt; &lt;!-- 对ProductDaoImpl类中的save方法进行增强 --&gt; &lt;!-- “*” 表示任意返回值类型 “..” 表示任意参数 --&gt; &lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.save(..))&quot;/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect ref=&quot;productEnhancer&quot;&gt; &lt;!-- 前置增强 --&gt; &lt;!-- 实现在调用save方法之前调用checkPri方法来进行权限校验--&gt; &lt;aop:before method=&quot;checkPri&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;/beans&gt; 至此切入点及切面都已配置完成，编写测试类和方法 12345678910111213141516171819202122232425262728293031323334import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;/** * AspectJ的XML方式配置测试类 * * @author Chen Rui * @version 1.0 **/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:aspectj-xml.xml&quot;)public class AppTest &#123; @Resource(name = &quot;productDao&quot;) private ProductDao productDao; @Test public void test()&#123; // 对save方法进行增强 productDao.save(); productDao.delete(); productDao.modify(); productDao.query(); &#125;&#125; 运行test()方法，控制台打印结果如下： 12345【前置增强】权限校验添加商品删除商品修改商品查询商品 至此就实现了在不修改ProductDaoImpl类的情况下，对其中的save()方法进行增强。 Spring中常用的增强类型前置增强在目标方法执行之前执行，可以获得切入点的信息 修改之前的ProductEnhancer类的checkPri()方法的参数。 123456789101112131415import org.aspectj.lang.JoinPoint;/** * ProductDao的增强类(切面类) * * @author Chen Rui * @version 1.0 **/public class ProductEnhancer &#123; public void checkPri(JoinPoint joinPoint)&#123; System.out.println(&quot;【前置增强】权限校验&quot; + joinPoint); &#125;&#125; 执行测试方法，控制台输出 12345【前置增强】权限校验execution(void learningspring.aop.aspectj.xml.demo2.ProductDao.save())添加商品删除商品修改商品查询商品 后置增强在目标方法执行之后执行，可以获得方法的返回值 首先修改ProductDao中的delete()方法的返回值类型，改成String 1234567891011121314151617181920212223242526272829/** * ProductDao * * @author Chen Rui * @version 1.0 **/public interface ProductDao &#123; /** * 添加商品 */ void save(); /** * 删除商品 */ String delete(); /** * 修改商品 */ void modify(); /** * 查询商品 */ void query();&#125; 再修改ProductDaoImpl中的delete()方法 123456789101112131415161718192021222324252627282930/** * ProductDao的实现类 * * @author Chen Rui * @version 1.0 **/public class ProductDaoImpl implements ProductDao &#123; @Override public void save() &#123; System.out.println(&quot;添加商品&quot;); &#125; @Override public String delete() &#123; System.out.println(&quot;删除商品&quot;); return new Date().toString(); &#125; @Override public void modify() &#123; System.out.println(&quot;修改商品&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询商品&quot;); &#125;&#125; 修改ProductEnhancer类，添加writeLog()方法，实现写日志功能 1234567891011121314151617181920212223242526/** * ProductDao的增强类(切面类) * * @author Chen Rui * @version 1.0 **/public class ProductEnhancer &#123; /** * 前置增强案例 * 在调用save方法之前进行权限校验 * @param joinPoint 切入点对象 */ public void checkPri(JoinPoint joinPoint)&#123; System.out.println(&quot;【前置增强】权限校验&quot; + joinPoint); &#125; /** * 后置增强案例 * 在调用delete方法之后，写入日志记录操作时间 * @param result 目标方法返回的对象 */ public void writeLog(Object result)&#123; System.out.println(&quot;【后置增强】写入日志 操作时间：&quot; + result.toString()); &#125;&#125; 然后修改aspectj.xml配置文件，配置新的切入点和切面 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 配置目标对象，即被增强的对象 --&gt; &lt;bean id=&quot;productDao&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductDaoImpl&quot;/&gt; &lt;!-- 将增强类(切面类)交给Spring管理 --&gt; &lt;bean id=&quot;productEnhancer&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductEnhancer&quot;/&gt; &lt;!-- 通过对AOP的配置完成对目标对象产生代理 --&gt; &lt;aop:config&gt; &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 --&gt; &lt;!-- 对ProductDaoImpl类中的save方法进行增强 --&gt; &lt;!-- “*” 表示任意返回值类型 “..” 表示任意参数 --&gt; &lt;!-- 前置增强的切入点配置 --&gt; &lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.save(..))&quot;/&gt; &lt;!-- 后置增强的切入点配置 --&gt; &lt;aop:pointcut id=&quot;pointcut2&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.delete(..))&quot;/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect ref=&quot;productEnhancer&quot;&gt; &lt;!-- 前置增强 --&gt; &lt;!-- 实现在调用save方法之前调用checkPri方法来进行权限校验--&gt; &lt;aop:before method=&quot;checkPri&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;!-- 后置增强 --&gt; &lt;!-- returning里面的值必须和writeLog()方法里的参数名相同，本案例为result--&gt; &lt;aop:after-returning method=&quot;writeLog&quot; returning=&quot;result&quot; pointcut-ref=&quot;pointcut2&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 执行测试方法，控制台打印结果 123456【前置增强】权限校验execution(void learningspring.aop.aspectj.xml.demo2.ProductDao.save())添加商品删除商品【后置增强】写入日志 操作时间：Tue Mar 19 15:59:48 CST 2019修改商品查询商品 环绕增强在目标方法执行之前和之后都执行 利用环绕增强来实现在调用modify()方法前后进行性能监控 首先修改ProductEnhancer类，添加monitor()方法 12345678910111213141516171819202122232425262728293031323334353637383940/** * ProductDao的增强类(切面类) * * @author Chen Rui * @version 1.0 **/public class ProductEnhancer &#123; /** * 前置增强案例 * 在调用save方法之前进行权限校验 * @param joinPoint 切入点对象 */ public void checkPri(JoinPoint joinPoint)&#123; System.out.println(&quot;【前置增强】权限校验&quot; + joinPoint); &#125; /** * 后置增强案例 * 在调用delete方法之后，写入日志记录操作时间 * @param result 目标方法返回的对象 */ public void writeLog(Object result)&#123; System.out.println(&quot;【后置增强】写入日志 操作时间：&quot; + result.toString()); &#125; /** * 环绕增强 * 在调用modify方法前后，显示性能参数 * @param joinPoint 切入点对象 * @throws Throwable 可抛出的异常 */ public Object monitor(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;); Object obj = joinPoint.proceed(); System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;); return obj; &#125;&#125; 然后再修改aspectj.xml配置文件，添加新的切入点和切面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 配置目标对象，即被增强的对象 --&gt; &lt;bean id=&quot;productDao&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductDaoImpl&quot;/&gt; &lt;!-- 将增强类(切面类)交给Spring管理 --&gt; &lt;bean id=&quot;productEnhancer&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductEnhancer&quot;/&gt; &lt;!-- 通过对AOP的配置完成对目标对象产生代理 --&gt; &lt;aop:config&gt; &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 --&gt; &lt;!-- 对ProductDaoImpl类中的save方法进行增强 --&gt; &lt;!-- “*” 表示任意返回值类型 “..” 表示任意参数 --&gt; &lt;!-- 前置增强的切入点配置 --&gt; &lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.save(..))&quot;/&gt; &lt;!-- 后置增强的切入点配置 --&gt; &lt;aop:pointcut id=&quot;pointcut2&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.delete(..))&quot;/&gt; &lt;!-- 环绕增强的切入点配置 --&gt; &lt;aop:pointcut id=&quot;pointcut3&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.modify(..))&quot;/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect ref=&quot;productEnhancer&quot;&gt; &lt;!-- 前置增强 --&gt; &lt;!-- 实现在调用save方法之前调用checkPri方法来进行权限校验--&gt; &lt;aop:before method=&quot;checkPri&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;!-- 后置增强 --&gt; &lt;!-- returning里面的值必须和writeLog()方法里的参数名相同，本案例为result--&gt; &lt;aop:after-returning method=&quot;writeLog&quot; returning=&quot;result&quot; pointcut-ref=&quot;pointcut2&quot;/&gt; &lt;!-- 环绕增强 --&gt; &lt;aop:around method=&quot;monitor&quot; pointcut-ref=&quot;pointcut3&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 运行测试方法，控制台打印结果： 12345678【前置增强】权限校验execution(void learningspring.aop.aspectj.xml.demo2.ProductDao.save())添加商品删除商品【后置增强】写入日志 操作时间：Tue Mar 19 15:58:49 CST 2019【环绕增强】当前空闲内存185MB修改商品【环绕增强】当前空闲内存185MB查询商品 异常抛出增强在程序出现异常时执行 利用异常抛出增强来实现获取异常信息的功能 首先修改ProductDaoImpl中的query()方法，使该方法抛出异常 123456789101112131415161718192021222324252627282930/** * ProductDao的实现类 * * @author Chen Rui * @version 1.0 **/public class ProductDaoImpl implements ProductDao &#123; @Override public void save() &#123; System.out.println(&quot;添加商品&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询商品&quot;); int a = 1/0; &#125; @Override public void modify() &#123; System.out.println(&quot;修改商品&quot;); &#125; @Override public String delete() &#123; System.out.println(&quot;删除商品&quot;); return new Date().toString(); &#125;&#125; 接着修改ProductEnhancer类，添加exception()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * ProductDao的增强类(切面类) * * @author Chen Rui * @version 1.0 **/public class ProductEnhancer &#123; /** * 前置增强案例 * 在调用save方法之前进行权限校验 * @param joinPoint 切入点对象 */ public void checkPri(JoinPoint joinPoint)&#123; System.out.println(&quot;【前置增强】权限校验&quot; + joinPoint); &#125; /** * 后置增强案例 * 在调用delete方法之后，写入日志记录操作时间 * @param result 目标方法返回的对象 */ public void writeLog(Object result)&#123; System.out.println(&quot;【后置增强】写入日志 操作时间：&quot; + result.toString()); &#125; /** * 环绕增强 * 在调用modify方法前后，显示性能参数 * @param joinPoint 切入点对象 * @throws Throwable 可抛出的异常 */ public Object monitor(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;); Object obj = joinPoint.proceed(); System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;); return obj; &#125; /** * 异常抛出增强 * 在调用query时若抛出异常则打印异常信息 * @param ex 异常对象 */ public void exception(Throwable ex)&#123; System.out.println(&quot;【异常抛出增强】&quot; + &quot;异常信息：&quot; +ex.getMessage()); &#125;&#125; 然后再修改aspectj-xml.xml配置文件，添加新的切入点和切面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 配置目标对象，即被增强的对象 --&gt; &lt;bean id=&quot;productDao&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductDaoImpl&quot;/&gt; &lt;!-- 将增强类(切面类)交给Spring管理 --&gt; &lt;bean id=&quot;productEnhancer&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductEnhancer&quot;/&gt; &lt;!-- 通过对AOP的配置完成对目标对象产生代理 --&gt; &lt;aop:config&gt; &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 --&gt; &lt;!-- 对ProductDaoImpl类中的save方法进行增强 --&gt; &lt;!-- “*” 表示任意返回值类型 “..” 表示任意参数 --&gt; &lt;!-- 前置增强的切入点配置 --&gt; &lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.save(..))&quot;/&gt; &lt;!-- 后置增强的切入点配置 --&gt; &lt;aop:pointcut id=&quot;pointcut2&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.delete(..))&quot;/&gt; &lt;!-- 环绕增强的切入点配置 --&gt; &lt;aop:pointcut id=&quot;pointcut3&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.modify(..))&quot;/&gt; &lt;!-- 异常抛出增强的切入点配置 --&gt; &lt;aop:pointcut id=&quot;pointcut4&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.query(..))&quot;/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect ref=&quot;productEnhancer&quot;&gt; &lt;!-- 前置增强 --&gt; &lt;!-- 实现在调用save方法之前调用checkPri方法来进行权限校验--&gt; &lt;aop:before method=&quot;checkPri&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;!-- 后置增强 --&gt; &lt;!-- returning里面的值必须和writeLog()方法里的参数名相同，本案例为result--&gt; &lt;aop:after-returning method=&quot;writeLog&quot; returning=&quot;result&quot; pointcut-ref=&quot;pointcut2&quot;/&gt; &lt;!-- 环绕增强 --&gt; &lt;aop:around method=&quot;monitor&quot; pointcut-ref=&quot;pointcut3&quot;/&gt; &lt;!-- 异常抛出增强 --&gt; &lt;aop:after-throwing method=&quot;exception&quot; throwing=&quot;ex&quot; pointcut-ref=&quot;pointcut4&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 最后执行测试方法，控制台输出结果： 123456789【前置增强】权限校验execution(void learningspring.aop.aspectj.xml.demo2.ProductDao.save())添加商品删除商品【后置增强】写入日志 操作时间：Tue Mar 19 15:58:16 CST 2019【环绕增强】当前空闲内存183MB修改商品【环绕增强】当前空闲内存183MB查询商品【异常抛出增强】异常信息：/ by zero 最终增强无论代码是否有异常最终都会执行 继续在异常抛出增强的代码修改，实现无论是否抛出异常都会打印当前时间信息 首先修改ProductEnhancer类，添加finallyAdvice()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * ProductDao的增强类(切面类) * * @author Chen Rui * @version 1.0 **/public class ProductEnhancer &#123; /** * 前置增强案例 * 在调用save方法之前进行权限校验 * @param joinPoint 切入点对象 */ public void checkPri(JoinPoint joinPoint)&#123; System.out.println(&quot;【前置增强】权限校验&quot; + joinPoint); &#125; /** * 后置增强案例 * 在调用delete方法之后，写入日志记录操作时间 * @param result 目标方法返回的对象 */ public void writeLog(Object result)&#123; System.out.println(&quot;【后置增强】写入日志 操作时间：&quot; + result.toString()); &#125; /** * 环绕增强 * 在调用modify方法前后，显示性能参数 * @param joinPoint 切入点对象 * @throws Throwable 可抛出的异常 */ public Object monitor(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;); Object obj = joinPoint.proceed(); System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;); return obj; &#125; /** * 异常抛出增强 * 在调用query时若抛出异常则打印异常信息 * @param ex 异常对象 */ public void exception(Throwable ex)&#123; System.out.println(&quot;【异常抛出增强】&quot; + &quot;异常信息：&quot; +ex.getMessage()); &#125; /** * 最终增强 * 无论query方法是否抛出异常都打印当前时间 */ public void finallyAdvice()&#123; System.out.println(&quot;【最终增强】&quot; + new Date().toString()); &#125;&#125; 修改aspectj.xml配置文件，添加新的切面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 配置目标对象，即被增强的对象 --&gt; &lt;bean id=&quot;productDao&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductDaoImpl&quot;/&gt; &lt;!-- 将增强类(切面类)交给Spring管理 --&gt; &lt;bean id=&quot;productEnhancer&quot; class=&quot;learningspring.aop.aspectj.xml.demo2.ProductEnhancer&quot;/&gt; &lt;!-- 通过对AOP的配置完成对目标对象产生代理 --&gt; &lt;aop:config&gt; &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 --&gt; &lt;!-- 对ProductDaoImpl类中的save方法进行增强 --&gt; &lt;!-- “*” 表示任意返回值类型 “..” 表示任意参数 --&gt; &lt;!-- 前置增强的切入点配置 --&gt; &lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.save(..))&quot;/&gt; &lt;!-- 后置增强的切入点配置 --&gt; &lt;aop:pointcut id=&quot;pointcut2&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.delete(..))&quot;/&gt; &lt;!-- 环绕增强的切入点配置 --&gt; &lt;aop:pointcut id=&quot;pointcut3&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.modify(..))&quot;/&gt; &lt;!-- 异常抛出增强的切入点配置 --&gt; &lt;aop:pointcut id=&quot;pointcut4&quot; expression=&quot;execution(* learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.query(..))&quot;/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect ref=&quot;productEnhancer&quot;&gt; &lt;!-- 前置增强 --&gt; &lt;!-- 实现在调用save方法之前调用checkPri方法来进行权限校验--&gt; &lt;aop:before method=&quot;checkPri&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;!-- 后置增强 --&gt; &lt;!-- returning里面的值必须和writeLog()方法里的参数名相同，本案例为result--&gt; &lt;aop:after-returning method=&quot;writeLog&quot; returning=&quot;result&quot; pointcut-ref=&quot;pointcut2&quot;/&gt; &lt;!-- 环绕增强 --&gt; &lt;aop:around method=&quot;monitor&quot; pointcut-ref=&quot;pointcut3&quot;/&gt; &lt;!-- 异常抛出增强 --&gt; &lt;aop:after-throwing method=&quot;exception&quot; throwing=&quot;ex&quot; pointcut-ref=&quot;pointcut4&quot;/&gt; &lt;!-- 最终增强 --&gt; &lt;aop:after method=&quot;finallyAdvice&quot; pointcut-ref=&quot;pointcut4&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 最后运行测试代码，控制台输出结果： 12345678910【前置增强】权限校验execution(void learningspring.aop.aspectj.xml.demo2.ProductDao.save())添加商品删除商品【后置增强】写入日志 操作时间：Tue Mar 19 15:57:01 CST 2019【环绕增强】当前空闲内存183MB修改商品【环绕增强】当前空闲内存183MB查询商品【最终增强】Tue Mar 19 15:57:01 CST 2019【异常抛出增强】异常信息：/ by zero AOP切入点表达式语法AOP切入点表达式是基于execution的函数完成的 语法：**[访问修饰符] 方法返回值 包名.类名.方法名(参数)** “*” 表示任意返回值类型“..” 表示任意参数 public void learningspring.aop.aspectj.xml.demo2.ProductDaoImpl.save(..) ：具体到某个增强的方法 * *.*.*.*Dao.save(..) ：所有包下的所有以Dao结尾的类中的save方法都会被增强 * learningspring.aop.aspectj.xml.demo2.ProductDaoImpl+.save(..) ：ProductDaoImpl及其子类的save方法都会被增强 * learningspring.aop.aspectj.xml..*.*(..)：xml包及其子包的所有类的方法都会被增强 AspectJ的注解配置案例首先也是创建一个接口ProductDao 12345678910111213141516171819202122232425262728/** * ProductDao接口 * * @author Chen Rui * @version 1.0 **/public interface ProductDao &#123; /** * 添加商品 */ void save(); /** * 查询商品 */ void query(); /** * 修改商品 */ void modify(); /** * 删除商品 */ String delete();&#125; 然后创建一个Dao实现类ProductDaoImpl 123456789101112131415161718192021222324252627282930/** * ProductDao的实现类 * * @author Chen Rui * @version 1.0 **/public class ProductDaoImpl implements ProductDao &#123; @Override public void save() &#123; System.out.println(&quot;添加商品&quot;); &#125; @Override public String delete() &#123; System.out.println(&quot;删除商品&quot;); return new Date().toString(); &#125; @Override public void modify() &#123; System.out.println(&quot;修改商品&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询商品&quot;); int a = 1/0; &#125;&#125; 接着创建增强类ProductEnhancer，在该类里面使用注解 使用@Pointcut注解可以配置切入点信息，在较多的方法都要使用同一个增强时，就可以配置一个切入点让目标方法都去引用 @Before：前置增强 @AfterReturning：后置增强，其中的returning的值必须和方法传入的参数名相同 @Around：环绕增强 @AfterThrowing：异常抛出增强，其中的throwing的值必须和方法传入的参数名相同 @After：最终增强 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * ProductDao的增强类(切面类) * * @author Chen Rui * @version 1.0 **/@Aspectpublic class ProductEnhancer &#123; /** * 切入点配置 * 对ProductDaoImpl里的方法都增强 */ @Pointcut(value = &quot;execution(* learningspring.aop.aspectj.annotation.demo2.ProductDaoImpl.*(..))&quot;) private void pointcut1()&#123;&#125; /** * 前置增强案例 * 在调用save方法之前进行权限校验 * @param joinPoint 切入点对象 */ @Before(value = &quot;execution(* learningspring.aop.aspectj.annotation.demo2.ProductDaoImpl.save())&quot;) public void checkPri(JoinPoint joinPoint)&#123; System.out.println(&quot;【前置增强】权限校验&quot; + joinPoint); &#125; /** * 后置增强案例 * 在调用delete方法之后，写入日志记录操作时间 * @param result 目标方法返回的对象 */ @AfterReturning(returning = &quot;result&quot;, value = &quot;execution(* learningspring.aop.aspectj.annotation.demo2.ProductDaoImpl.delete())&quot;) public void writeLog(Object result)&#123; System.out.println(&quot;【后置增强】写入日志 操作时间：&quot; + result.toString()); &#125; /** * 环绕增强 * 在调用modify方法前后，显示性能参数 * @param joinPoint 切入点对象 * @throws Throwable 可抛出的异常 */ @Around(value = &quot;execution(* learningspring.aop.aspectj.annotation.demo2.ProductDaoImpl.modify())&quot;) public Object monitor(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;); Object obj = joinPoint.proceed(); System.out.println(&quot;【环绕增强】当前空闲内存&quot; + Runtime.getRuntime().freeMemory()/(1024 * 1024) + &quot;MB&quot;); return obj; &#125; /** * 异常抛出增强 * 在调用query时若抛出异常则打印异常信息 * @param ex 异常对象 */ @AfterThrowing(throwing = &quot;ex&quot;, value = &quot;execution(* learningspring.aop.aspectj.annotation.demo2.ProductDaoImpl.query())&quot;) public void exception(Throwable ex)&#123; System.out.println(&quot;【异常抛出增强】&quot; + &quot;异常信息：&quot; +ex.getMessage()); &#125; /** * 最终增强 * 无论ProductDaoImpl里的每个方法是否抛出异常都打印当前时间 */ @After(value = &quot;pointcut1()&quot;) public void finallyAdvice()&#123; System.out.println(&quot;【最终增强】&quot; + new Date().toString()); &#125;&#125; 编写测试方法 1234567891011121314151617181920212223242526/** * AspectJ的注解方式配置测试类 * * @author Chen Rui * @version 1.0 **/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:aspectj-annotation.xml&quot;)public class AppTest &#123; @Resource(name = &quot;productDao&quot;) private ProductDao productDao; @Test public void test()&#123; productDao.save(); productDao.delete(); productDao.modify(); productDao.query(); &#125;&#125; 运行，控制台输出 12345678910111213【前置增强】权限校验execution(void learningspring.aop.aspectj.annotation.demo2.ProductDao.save())添加商品【最终增强】Tue Mar 19 16:01:06 CST 2019删除商品【最终增强】Tue Mar 19 16:01:06 CST 2019【后置增强】写入日志 操作时间：Tue Mar 19 16:01:06 CST 2019【环绕增强】当前空闲内存186MB修改商品【环绕增强】当前空闲内存186MB【最终增强】Tue Mar 19 16:01:06 CST 2019查询商品【最终增强】Tue Mar 19 16:01:06 CST 2019【异常抛出增强】异常信息：/ by zero Spring JDBC TemplateSpring提供了提供了多种持久层技术的模板类 ORM持久化技术 模板类 JDBC org.springframework.jdbc.core.JdbcTemplate Hibernate3.0 org.springframework.orm.hibernate3.HibernateTemplate IBatis(Mybatis) org.springframework.orm.ibatis.SqlMapClientTemplate JPA org.springframework.orm.jpa.JpaTemplate JDBC Template的入门首先引入jar包，在pom.xml文件中加入spring-jdbc，spring-tx，mysql-connector-java（本案例使用的是MySQL8）三个依赖。 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.14.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.14.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt; 然后创建数据库表，本例使用的MySQL8 12345678create table account( id int auto_increment primary key, name varchar(8) not null, money double default 0)comment &#x27;账户表&#x27;; 基本使用最基本的使用，不依赖于Spring 的管理，手动创建对象，采用硬编码的方式进行属性注入。不推荐使用该方法。 1234567891011121314151617181920public class AppTest &#123; /** * 硬编码 */ @Test public void test1()&#123; // 创建连接池 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/springjdbc?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false &quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;123456&quot;); // 创建JDBC Template JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); int i = jdbcTemplate.update(&quot;INSERT INTO account VALUES (null ,?,?)&quot;, &quot;Tom&quot;, 20000d); if (i &gt; 0)&#123; System.out.println(&quot;Update Successful&quot;); &#125; &#125;&#125; 接下来使用第二种方法，把连接池对象和模板(Template)都交给Spring来管理 创建spring-jdbc.xml该文件用来管理Bean 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 配置数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/springjdbc?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置Spring JDBC Template --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 在测试类中加入相应的注解，以及配置文件信息，编写新的测试方法 12345678910111213141516171819202122232425/** * Spring JDBC Template的使用 * * @author Chen Rui * @version 1.0 **/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:spring-jdbc.xml&quot;)public class AppTest &#123; /** * Spring 配置文件方式 * 把连接池和模板(Template)都交给spring管理 * 日志信息：Loaded JDBC driver: com.mysql.cj.jdbc.Driver * 是使用的默认的连接池 */ @Resource(name = &quot;jdbcTemplate&quot;) private JdbcTemplate jdbcTemplate; @Test public void test2()&#123; int i = jdbcTemplate.update(&quot;INSERT INTO account VALUES (null ,?,?)&quot;, &quot;Jack&quot;, 30000d); if (i &gt; 0)&#123; System.out.println(&quot;Update Successful&quot;); &#125; &#125; 通过@Resource注解从IOC容器中获取到模板对象，然后通过该模板对象来操作数据库。 这样就完成了Spring JDBC Template的最基本使用 数据库连接池在实际开发中，可能并不会使用默认的连接池，而是去使用一些开源的数据库连接池，在该例中介绍两种数据库连接池DBCP和C3P0 DBCP连接池的配置首先创建连接数据库的配置文件db.properties，注意，不同的MySQL版本可能url信息会不同，比如MySQL8就需要添加serverTimezone参数。 1234jdbc.driverClassName=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/springjdbc?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false jdbc.username=rootjdbc.password=123456 接着创建一个新的配置文件spring-dbcp.xml和前面的配置文件做区分。 利用context:property-placeholder标签引入db.properties配置文件，通过$&#123;key&#125;的方式来获取对应的value。 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 引入数据库配置文件 --&gt; &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt; &lt;!-- 配置DBCP连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置Spring JDBC Template --&gt; &lt;bean id=&quot;jdbcTemplateDBCP&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 编写测试方法 12345678910111213141516171819202122232425/** * Spring JDBC Template的使用 * * @author Chen Rui * @version 1.0 **/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:spring-dbcp.xml&quot;)public class AppTest &#123; //使用开源的数据库连接池进行配置 /** * 使用DBCP连接池 */ @Resource(name = &quot;jdbcTemplateDBCP&quot;) private JdbcTemplate jdbcTemplateDBCP; @Test public void test3()&#123; int i = jdbcTemplateDBCP.update(&quot;INSERT INTO account VALUES (null ,?,?)&quot;, &quot;Lucy&quot;, 40000d); if (i &gt; 0)&#123; System.out.println(&quot;Update Successful&quot;); &#125; &#125;&#125; C3P0连接池配置同样是创建一个新的配置文件spring-c3p0.xml，以作区分，同时也要引入数据库配置文件db.properties 要注意property标签的name属性和前面的配置文件稍有不同 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 引入数据库配置文件 --&gt; &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt; &lt;!-- 配置C3P0连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置Spring JDBC Template --&gt; &lt;bean id=&quot;jdbcTemplateC3P0&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 编写测试方法 1234567891011121314151617181920212223242526/** * Spring JDBC Template的使用 * * @author Chen Rui * @version 1.0 **/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:spring-*.xml&quot;)public class AppTest &#123; //使用开源的数据库连接池进行配置 /** * 使用C3P0连接池 */ @Resource(name = &quot;jdbcTemplateC3P0&quot;) private JdbcTemplate jdbcTemplateC3P0; @Test public void test4()&#123; int i = jdbcTemplateC3P0.update(&quot;INSERT INTO account VALUES (null ,?,?)&quot;, &quot;Lily&quot;, 50000d); if (i &gt; 0)&#123; System.out.println(&quot;Update Successful&quot;); &#125; &#125;&#125; 完成基本的CRUD操作以下内容都是使用的C3P0连接池，并且通过@Resource注解从IOC容器中获取了jdbcTemplateC3P0对象 插入操作12345678910/** * 插入操作 */@Testpublic void test()&#123; int i = jdbcTemplateC3P0.update(&quot;INSERT INTO account VALUES (null ,?,?)&quot;, &quot;Lily&quot;, 50000d); if (i &gt; 0)&#123; System.out.println(&quot;Update Successful&quot;); &#125;&#125; 修改操作12345678910/** * 修改操作 */@Testpublic void test()&#123; int i = jdbcTemplateC3P0.update(&quot;UPDATE account SET name = ? WHERE id = ?&quot;, &quot;Bob&quot;, 1); if (i &gt; 0)&#123; System.out.println(&quot;Update Successful&quot;); &#125;&#125; 删除操作12345678910/** * 删除操作 */@Testpublic void test()&#123; int i = jdbcTemplateC3P0.update(&quot;DELETE FROM account WHERE id = ?&quot;, 2); if (i &gt; 0)&#123; System.out.println(&quot;Delete Successful&quot;); &#125;&#125; 查询操作查询某个属性123456789101112131415161718192021222324/** * 查询操作 * * 查询单个字符串结果 */@Testpublic void test()&#123; String result = jdbcTemplateC3P0.queryForObject(&quot;SELECT name FROM account WHERE id = ?&quot;, String.class, 1); if (result != null)&#123; System.out.println(result); &#125; else&#123; System.out.println(&quot;NULL&quot;); &#125;&#125;/** * 统计查询 * 返回数据表中的记录数 */@Testpublic void test()&#123; Long result = jdbcTemplateC3P0.queryForObject(&quot;SELECT COUNT(*) FROM account&quot;, Long.class); System.out.println(result);&#125; 查询返回单个对象要实现查询的数据封装成一个对象的话，查询queryForObject的参数列表可知需要一个rowMapper的参数。所以需要创建一个执行数据封装的类来实现RowMapper&lt;T&gt;接口里的mapRow方法，在这个方法里进行数据对象的封装。 1234567891011121314151617/** * 数据封装类 * * @author Chen Rui * @version 1.0 **/public class MyRowMapper implements RowMapper&lt;Account&gt; &#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); account.setId(rs.getInt(&quot;id&quot;)); account.setName(rs.getString(&quot;name&quot;)); account.setMoney(rs.getDouble(&quot;money&quot;)); return account; &#125;&#125; 编写测试方法 12345678910111213/** * 将查询的结果封装成对象 * 要创建一个自定义rowMapper来实现RowMapper接口 */@Testpublic void test()&#123; Account account = jdbcTemplateC3P0.queryForObject(&quot;SELECT * FROM account WHERE id = ?&quot;, new MyRowMapper(), 1); if (account != null)&#123; System.out.println(account); &#125; else&#123; System.out.println(&quot;NULL&quot;); &#125;&#125; 查询返回对象集合要实现查询返回对象集合依然需要自定义类实现RowMapper&lt;T&gt;接口，调用的是query方法 12345678/** * 查询多条记录 */@Testpublic void test10()&#123; List&lt;Account&gt; accounts = jdbcTemplateC3P0.query(&quot;SELECT * FROM account&quot;, new MyRowMapper()); accounts.forEach(System.out::println);&#125; Spring事务管理什么是事务事务：逻辑上的一组操作，组成这组操作的各个单元，要么全部成功，要么全部失败。 事务的特性 原子性：事务不可分割 一致性：事务执行前后数据完整性保持一致 隔离性：一个事务的执行不应该受到其他事务的干扰 持久性：一旦事务结束，数据就持久化到数据库 不考虑隔离性引发的安全性问题 读问题 脏读：A事务读到B事务未提交的数据 不可重复读：B事务在A事务两次读取数据之间，修改了数据，导致A事务两次读取结果不一致 幻读&#x2F;虚读：B事务在A事务批量修改数据时，插入了一条新的数据，导致数据库中仍有一条数据未被修改。 写问题 丢失更新： 解决读问题 设置事务的隔离级别 Read uncommitted：未提交读，任何读问题都解决不了 Read committed：已提交读，解决脏读，但是不可重复读和幻读有可能发生 Repeatable read：重复读，解决脏读和不可重复读，但是幻读有可能发生 Serializable：解决所有读问题，因为禁止并行执行 Spring事务管理API PlatformTransactionManager：平台事务管理器 DataSourceTransactionManager：底层使用JDBC管理事务 TransactionDefinition：事务定义信息 ​ 用于定义事务相关的信息，隔离级别，超时信息，传播行为，是否只读…… TransactionStatus：事务的状态 ​ 用于记录在事务管理过程中，事务的状态 API的关系： Spring在进行事务管理的时候，首先平台事务管理器根据事务定义信息进行事务的管理，在事务管理过程中，产生各种状态，将这些状态信息记录到事务状态对象 Spring事务的传播行为首先假设一个背景，Service1里的x()方法已经定义了一个事务，Service2里的y()方法也有一个事务，但现在新增一行代码在Service2的y()方法中要先调用Service1里的x()方法然后再执行本身的方法。这时就涉及到事务的传播行为。 Spring中提供了7种传播行为 假设x()方法称为A，y()方法称为B 保证多个操作在同一个事务中 PROPAGATION_REQUIRED(*)：Spring事务隔离级别的默认值。如果A中有事务，则使用A中的事务。如果没有，则创建一个新的事务，将操作包含进来。 PROPAGATION_SUPPORTS：支持事务。如果A中有事务，使用A中的事务。如果A没有事务，则不使用事务。 PROPAGATION_MANDATORY：如果A中有事务，使用A中的事务。如果没有事务，则抛出异常。 保证多个事务不在同一个事务中 PROPAGATION_REQUIRES_NEW(*)：如果A中有事务，将A的事务挂起，创建新事务，只包含自身操作。如果A中没有事务，创建一个新事物，包含自身操作。 PROPAGATION_NOT_SUPPORTED：如果A中有事务，将A的事务挂起，不使用事务。 PROPAGATION_NEVER：如果A中有事务，则抛出异常。 嵌套式事务 PROPAGATION_NESTED(*)：嵌套事务，如果A中有事务，则按照A的事务执行，执行完成后，设置一个保存点，再执行B中的操作，如果无异常，则执行通过，如果有异常，则可以选择回滚到初始位置或者保存点。 Spring事务管理案例——转账情景转账情景实现首先创建接口AccountDao，定义两个方法分别是out和in 12345678910111213141516171819202122232425/** * AccountDao * * @author Chen Rui * @version 1.0 **/public interface AccountDao &#123; /** * 转出 * * @param from 转出账户 * @param money 转出金额 */ void out(String from, double money); /** * 转入 * * @param to 转入账户 * @param money 转入金额 */ void in(String to, double money);&#125; 接着创建实现类AccountDaoImpl实现out和in方法并且继承JdbcSupport类。这样就可以直接使用父类的JDBCTemplate对象。 12345678910111213141516171819/** * AccountDao实现类 * * @author Chen Rui * @version 1.0 **/public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123; @Override public void out(String from, double money) &#123; this.getJdbcTemplate().update(&quot;UPDATE account SET money = money - ? WHERE name = ?&quot;, money, from); &#125; @Override public void in(String to, double money) &#123; this.getJdbcTemplate().update(&quot;UPDATE account SET money = money + ? WHERE name = ?&quot;, money, to); &#125;&#125; 然后创建接口AccountrService，定义transfer方法 1234567891011121314151617/** * AccountService * * @author Chen Rui * @version 1.0 **/public interface AccountService &#123; /** * 转账 * @param from 转出账户 * @param to 转入账户 * @param money 交易金额 */ void transfer(String from, String to, Double money);&#125; 再创建类AccountServiceImpl实现该接口，并声明AccountDao引用并创建set方法 1234567891011121314151617181920/** * AccountService实现类 * * @author Chen Rui * @version 1.0 **/public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void transfer(String from, String to, Double money) &#123; accountDao.out(from, money); accountDao.in(to, money); &#125;&#125; 最后创建配置文件spring-tx-programmatic.xml，用来管理Bean。 引入数据库连接文件，配置数据源，创建Bean对象accountDao将数据源dataSource注入到accountDao中，再创建Bean对象accountService，将accountDao注入。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 编程式事务管理配置文件 --&gt; &lt;!-- 配置Service --&gt; &lt;bean id=&quot;accountService&quot; class=&quot;learningspring.transaction.programmatic.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置Dao --&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;learningspring.transaction.programmatic.AccountDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 引入数据库配置文件 --&gt; &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt; &lt;!-- 配置C3P0连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 到此一个转账模拟业务就实现了，数据库表依然使用前面创建的account表，先查询当前数据库的数据。 编写测试方法，实现让姓名为Bob的账户向Jack转账1000元。 123456789101112131415161718/** * 编程式事务测试类 * * @author Chen Rui * @version 1.0 **/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(value = &quot;classpath:spring-tx-programmatic.xml&quot;)public class AppTest &#123; @Resource(name = &quot;accountService&quot;) private AccountService accountService; @Test public void test()&#123; accountService.transfer(&quot;Bob&quot;,&quot;Jack&quot;,1000d); &#125;&#125; 运行结果 现在对类AccountServiceImpl里的transfer方法进行修改，让其发生异常，再观察结果 123456789101112131415161718192021222324/** * AccountService实现类 * * @author Chen Rui * @version 1.0 **/public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void transfer(String from, String to, Double money) &#123; accountDao.out(from, money); // 抛出异常 int i = 1/0; accountDao.in(to, money); &#125;&#125; 查询数据库数据 这时Bob账户的钱就少了1000元，而Jack账户也没有增加1000元。 所以就需要事务来进行管理。 编程式事务所谓编程式事务，就是要在源码中编写事务相关的代码。实现编程式事务，首先要在AccountServiceImpl中声明TransactionTemplate对象，并创建set方法。然后修改transfer参数列表所有参数都用final(因为使用了匿名内部类)修饰，并修改方法体内容。 1234567891011121314151617181920212223242526272829303132/** * AccountService实现类 * * @author Chen Rui * @version 1.0 **/public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; private TransactionTemplate transactionTemplate; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public void setTransactionTemplate(TransactionTemplate transactionTemplate) &#123; this.transactionTemplate = transactionTemplate; &#125; @Override public void transfer(final String from, final String to, final Double money) &#123; transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123; @Override protected void doInTransactionWithoutResult(TransactionStatus status) &#123; accountDao.out(from, money); // 抛出异常 int i = 1/0; accountDao.in(to,money); &#125; &#125;); &#125;&#125; 然后修改spring-tx-programmatic.xml文件，创建Bean对象transactionManager和transactionTemplate，并将transactionTemplate注入到accountService中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 编程式事务管理配置文件 --&gt; &lt;!-- 配置Service --&gt; &lt;bean id=&quot;accountService&quot; class=&quot;learningspring.transaction.programmatic.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt; &lt;property name=&quot;transactionTemplate&quot; ref=&quot;transactionTemplate&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置Dao --&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;learningspring.transaction.programmatic.AccountDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 引入数据库配置文件 --&gt; &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt; &lt;!-- 配置C3P0连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置模板 --&gt; &lt;bean id=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 此时异常依然存在，数据库数据仍然是上次执行的结果状态 再次运行测试方法，并查询结果，观察是否发生变化 现在就实现了编程式事务，当出现异常时，数据库的数据就不会被修改。 声明式事务XML配置方式声明式事务即通过配置文件实现，利用的就是Spring的AOP 修改类AccountServiceImpl，删除TransactionTemplate对象，并修改transfer方法，保留异常代码 12345678910111213141516171819202122/** * AccountService实现类 * * @author Chen Rui * @version 1.0 **/public class AccountServiceImpl implements AccountService&#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void transfer(String from, String to, Double money) &#123; accountDao.out(from, money); int i = 1/0; accountDao.in(to,money); &#125;&#125; 然后创建配置文件spring-tx-declarative.xml，配置数据源即Bean对象，然后配置事务管理器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 声明式事务管理配置文件 --&gt; &lt;!-- 配置Service --&gt; &lt;bean id=&quot;accountService&quot; class=&quot;learningspring.transaction.declarative.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置Dao --&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;learningspring.transaction.declarative.AccountDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 引入数据库配置文件 --&gt; &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt; &lt;!-- 配置C3P0连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 接着就配置事务的增强，配置文件中加入以下配置 12345678910111213&lt;!-- 配置事务的增强 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 配置事务的规则 根据实际业务修改--&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- AOP的配置 --&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* learningspring.transaction.declarative.AccountServiceImpl.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;&lt;/aop:config&gt; 先查看当前数据库数据 编写测试方法 123456789101112131415161718/** * 声明式事务配置测试类 * * @author Chen Rui * @version 1.0 **/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(value = &quot;classpath:spring-tx-declarative.xml&quot;)public class AppTest &#123; @Resource(name = &quot;accountService&quot;) private AccountService accountService; @Test public void test()&#123; accountService.transfer(&quot;Bob&quot;,&quot;Jack&quot;,1000d); &#125;&#125; 运行查看结果，是否变化 至此就实现了声明式事务XML方式的配置。 注解配置方式Spring的事务配置仍然支持注解配置 继续沿用spring-tx-declarative.xml文件，把事务增强和AOP相关的配置注释，并开启注解事务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 声明式事务管理配置文件 --&gt; &lt;!-- 配置Service --&gt; &lt;bean id=&quot;accountService&quot; class=&quot;learningspring.transaction.declarative.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置Dao --&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;learningspring.transaction.declarative.AccountDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 引入数据库配置文件 --&gt; &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt; &lt;!-- 配置C3P0连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置事务的增强 --&gt; &lt;!--&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;--&gt; &lt;!--&lt;tx:attributes&gt;--&gt; &lt;!-- 配置事务的规则 --&gt; &lt;!--&lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;--&gt; &lt;!--&lt;/tx:attributes&gt;--&gt; &lt;!--&lt;/tx:advice&gt;--&gt; &lt;!-- AOP的配置 --&gt; &lt;!--&lt;aop:config&gt;--&gt; &lt;!--&lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* learningspring.transaction.declarative.AccountServiceImpl.*(..))&quot;/&gt;--&gt; &lt;!--&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;--&gt; &lt;!--&lt;/aop:config&gt;--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt; 接下来就可以在业务层类上使用事务管理的注解了。修改AccountServiceImpl类，添加@Transactional注解 123456789101112131415161718192021222324/** * AccountService实现类 * * @author Chen Rui * @version 1.0 **/@Transactional(rollbackFor = Exception.class)public class AccountServiceImpl implements AccountService&#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void transfer(String from, String to, Double money) &#123; accountDao.out(from, money); int i = 1/0; accountDao.in(to,money); &#125;&#125; 再次运行测试方法，数据库也不会发生改变。","categories":[{"name":"代码学习","slug":"Codelearning","permalink":"http://blog.aiheadn.cn/categories/Codelearning/"},{"name":"框架学习","slug":"Codelearning/kuangjia","permalink":"http://blog.aiheadn.cn/categories/Codelearning/kuangjia/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://blog.aiheadn.cn/tags/spring/"}]},{"title":"基于前端Vue学习总结","slug":"基于前端Vue学习总结","date":"2023-03-08T02:45:15.000Z","updated":"2023-03-08T08:07:55.023Z","comments":true,"path":"archives/25f3330a.html","link":"","permalink":"http://blog.aiheadn.cn/archives/25f3330a.html","excerpt":"","text":"前言总结一下vue方便查阅 认识一下123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Vue Basic Example&lt;/tit le&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello, Vue!&#x27; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; vue官方文档查询使用：vue官方文档 vue指令属性绑定指令 在 Vue 中，属性绑定指令是指 v-bind 指令。v-bind 指令可以用来动态地将 HTML 属性与 Vue 实例中的数据绑定起来，以便在数据发生变化时自动更新页面。 在 Vue 中，v-bind 指令还有一种简写方式，即使用冒号（:）代替 v-bind:。 事件绑定的时候 变量用“” 字符串用‘’ 事件绑定指令事件修饰符按键修饰符双向绑定 v-model","categories":[{"name":"代码学习","slug":"Codelearning","permalink":"http://blog.aiheadn.cn/categories/Codelearning/"},{"name":"框架学习","slug":"Codelearning/kuangjia","permalink":"http://blog.aiheadn.cn/categories/Codelearning/kuangjia/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://blog.aiheadn.cn/tags/vue/"}]},{"title":"软件设计师中一些公式知识点","slug":"软件设计师中一些公式知识点","date":"2023-03-01T13:54:13.000Z","updated":"2023-03-08T08:06:30.583Z","comments":true,"path":"archives/8b4bd44a.html","link":"","permalink":"http://blog.aiheadn.cn/archives/8b4bd44a.html","excerpt":"","text":"校验码可靠度流水","categories":[{"name":"信息技术","slug":"xingxijishu","permalink":"http://blog.aiheadn.cn/categories/xingxijishu/"}],"tags":[{"name":"edu","slug":"edu","permalink":"http://blog.aiheadn.cn/tags/edu/"}]},{"title":"对于win系统的C盘进行瘦身","slug":"对于win系统的C盘进行瘦身","date":"2023-02-24T06:13:47.000Z","updated":"2023-02-26T12:53:26.783Z","comments":true,"path":"archives/679a4029.html","link":"","permalink":"http://blog.aiheadn.cn/archives/679a4029.html","excerpt":"","text":"前言记录一下清理电脑c盘的一下小技巧 清理c盘缓存1C:\\Users\\小ad\\AppData\\Local\\Temp 这个文件下的一般都是缓存","categories":[{"name":"信息技术","slug":"xingxijishu","permalink":"http://blog.aiheadn.cn/categories/xingxijishu/"}],"tags":[{"name":"C","slug":"C","permalink":"http://blog.aiheadn.cn/tags/C/"}]},{"title":"JAVA中常用方法总结","slug":"JAVA中常用方法总结","date":"2023-02-11T04:47:26.000Z","updated":"2023-02-11T05:13:46.496Z","comments":true,"path":"archives/bcf1045e.html","link":"","permalink":"http://blog.aiheadn.cn/archives/bcf1045e.html","excerpt":"","text":"前言总结一些常用的方法 String字符串长度12String str = &quot;aaaaaaaa&quot;; int len = str.length();//len代表此字符串的长度 charAt(int index)12String str=&quot; hello&quot;;System.out.println(str.charAt(3));//打印结果为e 连接字符串123String string1=&quot;我的名字是：&quot;;String string2=&quot;小花&quot;;string1.concat(string2);//此时打印结果为：我的名字是：小花 引用类型的整数转换字符串123456789101112131415161718public class IntToString &#123; public static void main(String[] args) &#123; Integer num = 456; //方式1 String str1 = String.valueOf(num); System.out.println(&quot;方式1的结果：&quot; + str1); //方式2 String str2 = Integer.toString(num); System.out.println(&quot;方式1的结果：&quot; + str2); //方式3 String str3 = num + &quot;&quot;; System.out.println(&quot;方式1的结果：&quot; + str3); &#125;&#125; 字符串比较12345678public class A &#123; public static void main(String[] args) &#123; String a = &quot;123&quot;; String b = &quot;123&quot;; System.out.println(a.equals(b)); &#125; &#125; Math123456789101112131415161718192021222324252627282930313233343536System.out.println(Math.sqrt(25)); //5.0 --计算平方根System.out.println(Math.cbrt(8)); //2.0 --计算立方根System.out.println(Math.pow(3,3)); //27.0 --计算a的b次方System.out.println(Math.max(88,8)); //88 --计算最大值System.out.println(Math.min(88,8)); //8 --计算最小值System.out.println(Math.abs(-13.14)); //13.14 --计算绝对值double a = 2.01;double b = Math.ceil(a); //向上取整System.out.println(b); //3.0double a = 8.99;double b = Math.floor(a); //向下取整System.out.println(b); //8.0double a = 5.4;double b = Math.round(a); //向上取整System.out.println(b);//5.0double a = 6.51;double b = Math.rint(a); //四舍五入 注意.5的时候会取偶数System.out.println(b); //7.0System.out.println(Math.random()); // [0, 1)的double类型的数System.out.println(Math.random() * 2);//[0, 2)的double类型的数System.out.println(Math.random() * 2 + 1);// [1, 3)的double类型的数 MapMap.containsKey(Object key)123456789101112131415public static void main(String[] args)&#123; Map map = new HashMap(); //定义Map对象 map.put(&quot;apple&quot;,&quot;新鲜的苹果&quot;); //向集合中添加对象 map.put(&quot;computer&quot;,&quot;配置优良的计算机&quot;); map.put(&quot;book&quot;,&quot;堆积成山的图书&quot;); map.put(&quot;time&quot;,new Date()); String key = &quot;book&quot;; boolean contains=map.containsKey(key); //判断是否包含指定的键值 if(contains)&#123; //如果条件为真 System.out.println(&quot;在Map集合中包含键名&quot;+key); //输出信息 &#125;else&#123; System.out.println(&quot;在Map集合中不包含键名&quot;+key); &#125;&#125;","categories":[{"name":"代码学习","slug":"Codelearning","permalink":"http://blog.aiheadn.cn/categories/Codelearning/"},{"name":"Java","slug":"Codelearning/Java","permalink":"http://blog.aiheadn.cn/categories/Codelearning/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.aiheadn.cn/tags/Java/"}]},{"title":"哔哩哔哩av和bv互相转换JAVA版本","slug":"哔哩哔哩av和bv互相转换JAVA版本","date":"2023-02-01T06:42:43.000Z","updated":"2023-02-01T11:52:16.362Z","comments":true,"path":"archives/9f02f0c2.html","link":"","permalink":"http://blog.aiheadn.cn/archives/9f02f0c2.html","excerpt":"","text":"前言哔哩哔哩逐渐从av转化到bv，但是好多代码框架还在使用av，这个是java版本的代码 两个版本可以互相转化。 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.HashMap;public class AvBv &#123; private static String table = &quot;fZodR9XQDSUm21yCkr6zBqiveYah8bt4xsWpHnJE7jL5VG3guMTKNPAwcF&quot;; private static HashMap&lt;String, Integer&gt; mp = new HashMap&lt;&gt;(); private static HashMap&lt;Integer, String&gt; mp2 = new HashMap&lt;&gt;(); static int ss[] = &#123;11, 10, 3, 8, 4, 6, 2, 9, 5, 7&#125;; static long xor = 177451812; static long add = 8728348608l; public static void main(String[] args) &#123; System.out.println(b2v(&quot;BV1d64y1q7KS&quot;)); System.out.println(v2b(&quot;av98464354&quot;)); //这里需要转化哪个就修改哪个 &#125; public static long power(int a, int b) &#123; long power = 1; for (int c = 0; c &lt; b; c++) power *= a; return power; &#125; public static String b2v(String s) &#123; long r = 0; for (int i = 0; i &lt; 58; i++) &#123; String s1 = table.substring(i, i + 1); mp.put(s1, i); &#125; for (int i = 0; i &lt; 6; i++) &#123; r = r + mp.get(s.substring(ss[i], ss[i] + 1)) * power(58, i); &#125; return &quot;av&quot; + ((r - add) ^ xor); &#125; public static String v2b(String st) &#123; long s = Long.valueOf(st.split(&quot;av&quot;)[1]); StringBuffer sb = new StringBuffer(&quot;BV1 4 1 7 &quot;); s = (s ^ xor) + add; for (int i = 0; i &lt; 58; i++) &#123; String s1 = table.substring(i, i + 1); mp2.put(i, s1); &#125; for (int i = 0; i &lt; 6; i++) &#123; String r = mp2.get((int) (s / power(58, i) % 58)); sb.replace(ss[i], ss[i] + 1, r); &#125; return sb.toString(); &#125;&#125;","categories":[{"name":"代码学习","slug":"Codelearning","permalink":"http://blog.aiheadn.cn/categories/Codelearning/"},{"name":"Java","slug":"Codelearning/Java","permalink":"http://blog.aiheadn.cn/categories/Codelearning/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.aiheadn.cn/tags/Java/"}]},{"title":"cmd常用命令","slug":"cmd常用命令","date":"2023-01-07T10:36:47.000Z","updated":"2023-02-06T16:37:11.647Z","comments":true,"path":"archives/65edf23c.html","link":"","permalink":"http://blog.aiheadn.cn/archives/65edf23c.html","excerpt":"","text":"前言记录一些我经常使用的cmd命令，持续更新 启用资源管理器explorer 返回上一级目录在默认的命令后加 cd.. 即可返回上一级目录","categories":[{"name":"代码学习","slug":"Codelearning","permalink":"http://blog.aiheadn.cn/categories/Codelearning/"}],"tags":[{"name":"cmd","slug":"cmd","permalink":"http://blog.aiheadn.cn/tags/cmd/"}]},{"title":"一些常用的网站文档","slug":"一些常用的网站文档","date":"2023-01-06T09:32:05.000Z","updated":"2023-03-01T03:29:10.580Z","comments":true,"path":"archives/1d5436e1.html","link":"","permalink":"http://blog.aiheadn.cn/archives/1d5436e1.html","excerpt":"","text":"前言主要用来记录一些我经常使用的网站查询资料 网站文档无涯教程：https://www.learnfk.com/ butterfly主题的标签外挂： https://butterfly.js.org/posts/2df239ce/ 有道翻译： https://fanyi.youdao.com/index.html#/ markdown官方文档： https://markdown.com.cn/cheat-sheet.html 图片在线压缩（以及站长功能）： https://www.bejson.com/ui/compress_img/ 文件格式转换：https://app.xunjiepdf.com/ppt2jpg/ 哔哩哔哩视频下载： https://bilibili.iiilab.com/ 网易见外工作台： https://jianwai.youdao.com/ 油猴 Greasy Fork： https://greasyfork.org/zh-CN Jquery：https://jquery.cuishifeng.cn/ JS官方文档： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript","categories":[{"name":"代码学习","slug":"Codelearning","permalink":"http://blog.aiheadn.cn/categories/Codelearning/"},{"name":"文档","slug":"Codelearning/doc","permalink":"http://blog.aiheadn.cn/categories/Codelearning/doc/"}],"tags":[{"name":"文档","slug":"doc","permalink":"http://blog.aiheadn.cn/tags/doc/"},{"name":"网站","slug":"web","permalink":"http://blog.aiheadn.cn/tags/web/"}]},{"title":"关于hexo配置汇总","slug":"关于hexo配置汇总","date":"2023-01-05T05:19:11.000Z","updated":"2023-02-01T06:33:04.249Z","comments":true,"path":"archives/1b4c065d.html","link":"","permalink":"http://blog.aiheadn.cn/archives/1b4c065d.html","excerpt":"","text":"前言这篇文章主要记录一下我在使用hexo博客遇到的一些问题，以及一些常用的配置，都汇总到这篇文章，持续性更新，以便忘记的时候方便查找。 分类名和标签名改成英文一般hexo都是部署在GitHub上面，修不修改都无所谓，我的网站是在个人云服务器上部署，对于Nginx上不支持中文url，这就很难受，在查找资料的时候发现可以修改成英文，如下 分类名称默认是你在文章里面设置的，如果是中文分类名，那么路径名也是中文了，特别别扭。我在文档上查到了一个名为 category_map 的设置项，就是一个键值对嘛。修改办法就是打开你的 Hexo 配置文件 _config.yml。修改 category_map 属性和tag_map属性大概按照这样的格式： 1234567891011category_map: &#x27;代码学习&#x27; : Codelearning &#x27;信息技术&#x27; : xingxijishu &#x27;平面设计&#x27; : plane &#x27;平面笔记&#x27; : planenote tag_map: &#x27;平面设计&#x27; : plane &#x27;博客&#x27; : blog &#x27;腾讯cos&#x27; : cos &#x27;API接口&#x27; : api 这样重新生成的静态文件，就会将中文转换为英文，这样做可能有点麻烦，每次都需要修改一下，所以标签尽量使用英文。修改前的urlhttp://blog.aiheadn.cn/categories/代码学习/修改后的urlhttp://blog.aiheadn.cn/categories/Codelearning/ 监视文件变动Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。 1hexo generate --watch hexo Butterfly主题文章置顶卸载hexo-generator-index，然后安装hexo-generator-index-pin-top 123npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save 使用方法：在需要置顶的文章的Front-matter中加上top: true&#x2F;数字即可，数字越大，文章越靠前。例如 12345cover: top: 1 #这里加一个top就行abbrlink: 1d5436e1date: 2023-01-06 17:32:05 文章模板很多小伙伴给自己个博客添加了很多其他的功能，但是每次写文章的时候都需要在文章的开头去写一遍，这简直就是重复造轮子。其实，你可以自己在scaffolds中去修改属于你自己的模板 hexo添加哔哩哔哩视频语法：&#123;% bili video_id %&#125; or &#123;% bili video_id page %&#125;用法 在 Hexo 博客运行中安装插件 npm i hexo-tag-bili --save 在 Hexo 帖子&#x2F;页面中 &#123;% bili video_id %&#125; or &#123;% bili video_id page %&#125; 例：https://www.bilibili.com/video/av24897960 &#123;% bili 24897960 %&#125; https://www.bilibili.com/video/av24897960/?p=2 &#123;% bili 24897960 2 %&#125; 插件仓库地址：https://github.com/honjun/hexo-tag-bili 持续更新","categories":[{"name":"代码学习","slug":"Codelearning","permalink":"http://blog.aiheadn.cn/categories/Codelearning/"},{"name":"hexo","slug":"Codelearning/hexo","permalink":"http://blog.aiheadn.cn/categories/Codelearning/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.aiheadn.cn/tags/hexo/"}]},{"title":"linux环境安装nodejs和npm环境","slug":"linux环境安装nodejs和npm环境","date":"2023-01-04T13:01:25.000Z","updated":"2023-01-05T03:35:05.309Z","comments":true,"path":"archives/53576780.html","link":"","permalink":"http://blog.aiheadn.cn/archives/53576780.html","excerpt":"","text":"前言因为刚刚换上hexo的框架，想利用私有部署把Twikoo评论部署在博客上，所以需要使用liunx安装node.js,网络上对于安装linux的资料很少，在我查找了一些资料之后终于把环境配置好，但是因为执行条命令 nohup tkserver &gt;&gt; tkserver.log 2&gt;&amp;1 &amp;一直报错，思考一个下午之后，最后换了另外一个评论系统。 安装npde.js第一步先安装nodejsnodejs官方网站找到需要下载的版本号，右键复制出下载地址 https://nodejs.org/dist/v18.12.1/node-v18.12.1-linux-x64.tar.xz利用Xshell连接你的服务器首先应该先进入目录 1cd /usr/local/ 新建一个nodejs的目录 1mkdir nodejs 6.cd到nodejs目录，用wget下载 这样就直接下载到你的目录里面 1wget https://nodejs.org/dist/v18.12.1/node-v18.12.1-linux-x64.tar.xz tar xf 解压文件 1tar xf node-v10.15.0-linux-x64.tar.xz mv 重命名为node18 这个命名自己清楚就行 1mv node-v10.15.0-linux-x64 nodejs18 配置环境变量ln -s设置node和npm软链接 （配置环境变量，这里的路径一定要自己清楚） 12ln -s /usr/local/nodejs/nodejs18/bin/node /usr/bin/nodeln -s /usr/local/nodejs/nodejs18/bin/npm /usr/bin/npm 如果配置错了的话 可以使用覆盖命令 in -sf 强制创建软链接（覆盖以前的链接） 输入node -v查看版本号 1node -v 配置成功后应该显示的是node的版本号，如果提示乱码的话，一般是linux的内核和node冲突了，可以选择降底版本。 安装cnpm这个是我看其他资料，我没有测试，因为我觉得npm速度还是可以的有时候用npm安装速度太慢，这时可以考虑安装cnpm 直接npm下载安装即可： cd到&#x2F;usr&#x2F;local&#x2F;nodejs目录 1npm install -g cnpm --registry=https://registry.npm.taobao.org 创建软连接 1ln -s /usr/local/nodejs/nodejs18/bin/cnpm /usr/bin/cnpm 查看版本：cnpm -v 看到以下信息即为成功 12345678910111213cnpm@6.0.0 (/usr/lib/node_modules/cnpm/lib/parse_argv.js)npm@6.5.0 (/usr/lib/node_modules/cnpm/node_modules/npm/lib/npm.js)node@10.15.0 (/usr/local/nodejs/nodejs10/bin/node)npminstall@3.19.1 (/usr/lib/node_modules/cnpm/node_modules/npminstall/lib/index.js)prefix=/usr/local/nodejs/nodejs10linux x64 3.10.0-693.2.2.el7.x86_64registry=https://registry.npm.taobao.org","categories":[{"name":"代码学习","slug":"Codelearning","permalink":"http://blog.aiheadn.cn/categories/Codelearning/"},{"name":"linux","slug":"Codelearning/linux","permalink":"http://blog.aiheadn.cn/categories/Codelearning/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://blog.aiheadn.cn/tags/linux/"},{"name":"node","slug":"node","permalink":"http://blog.aiheadn.cn/tags/node/"},{"name":"npm","slug":"npm","permalink":"http://blog.aiheadn.cn/tags/npm/"}]},{"title":"基于hexo+butterfly和Github pages博客","slug":"基于hexo+butterfly和Github pages博客","date":"2023-01-03T15:05:59.000Z","updated":"2023-02-01T06:27:05.757Z","comments":true,"path":"archives/eeace1a8.html","link":"","permalink":"http://blog.aiheadn.cn/archives/eeace1a8.html","excerpt":"","text":"前言在众多的博客中，我选择了hexo，最大的优势就是可以结合GitHub page来搭建一个免费的个人博客系统，将文章都托管到GitHub上，在也不用担心服务器过期的问题了，而且可以自己买一个域名，解析了GitHub上就可以直接使域名访问了，不过因为有自己的服务器，所以我直接部署在了自己的服务器上面。 环境搭建：NodeJs+Git+Hexo1.下载安装 node.js 我们可以验证node的版本号和它所附带的npm包管理器版本号： 1234# 使用以下命令检查版本，如果正确输出则表示安装成功# CMD输入：node -vnpm v 切换国内源，使用cnpm（马云爸爸的连接更快喔~) 12# CMD输入：npm install -g cnpm --registry=https://registry.npm.taobao.org 查看cnpm的版本 123456789CMD输入:cnpm -v# 打印的信息：cnpm@6.1.1 npm@6.14.11 node@14.15.4 npminstall@3.28.0 win32 x64 10.0.18363registry=https://r.npm.taobao.org 2.安装git 点我下载 一样的方法，安装好后会出现三个快捷方式 git cmd git bash安装成功如下图： 3.hexo安装使用以下命令安装hexo包，-g表示全局安装cnpm install hexo -g 在你想要的地方新建一个专门来放置hexo博客内容的文件夹，这里我命名为hexo，这里我是E:\\hexocmd到这个文件夹根目录： 12base：E:base: cd hexo/ 然后运行hexo init命令来在这个文件夹初始化一些hexo的基本文件输出信息如下： 12345678910(base) E:\\hexo&gt;hexo initINFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.git[32mINFO [39m Install dependenciesadded 188 packages from 443 contributors and audited 194 packages in 34.032s15 packages are looking for funding run `npm fund` for detailsfound 0 vulnerabilitiesINFO Start blogging with Hexo! 文件夹下的对应生成文件： 接下来看看hexo的一些常用基本命令： 1234567891011hexo init &lt;folder&gt; # 执行init命令初始化hexo到你指定的目录hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; # 新建文章hexo generate # 根据当前目录下文件,生成静态网页 简写：hexo ghexo server # 运行本地服务 简写：hexo shexo clean # 清理hexo deploy # 部署 简写：hexo dhexo server # Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s # 静态模式hexo server -p 5000 # 更改端口hexo server -i 192.168.1.1 # 自定义 IP 查看hexo的初始化博客页面： 在cmd输入 hexo s -g 即生成静态网页然后启动本地服务 然后在浏览器(推荐Chrome)打开http://localhost:4000 (4000是默认port) 以上就是hexo的原生态主题。 到此为止，我们搭建hexo的本地初始化已经完成，之后就是更换主题，我个人使用的是Butterfly，下面我们讲讲如何更换Butterfly主题 更换之前，我们先来了解一下hexo各个文件夹的含义。 目录了解123456789101112131415161718192021hexo-install-directory├── CNAME├── _config.yml //Hexo的配置文件，可以配置主题、语言等├── avatar.jpg├── db.json├── debug.log├── node_modules├── public //执行hexo g命令后，生成的内容会在这里，包括所有的文章、页面、分类、tag等.├── scaffolds //保存着默认模板，自定义模板就是修改该目录下的文件│ ├── draft.md //默认的草稿模板│ ├── page.md //默认的页面模板│ └── post.md //默认的文章模板├── source //Hexo存放编辑页面的地方，可以使用vim或其他编辑器编辑这里的内容│ ├── 404.html //自定义404页面，可以使用腾讯公益404页面│ ├── Staticfile │ ├── _drafts //存放所有的草稿文件的目录│ ├── _posts //存放所有的文章文件的目录，用的最多，比如执行hexo new &quot;post_name&quot;之后，post_name这篇文章就存放在这个目录下│ ├── categories└── themes //Hexo的所有主题 ├── landscape //原始hexo主题 ├── butterfly //这是我目前用的主题 Butterfly主题仓库地址 https://github.com/jerryc127/hexo-theme-butterfly 研究一个程序，最好要看看程序的文档，蝴蝶文档 如何安装和美化文档写的非常完整，因为太过于繁琐，可以对照着视频去看。 我这里参考的是哔哩哔哩卷二兔的视频完成配置。 部署服务器配置好之后就可以上线到远程网站。 部署网站有很多种方法 可以使用GitHub page Gitee page都可以，具体网络上有非常多的教程，只要有一个域名就可以。 而自建服务器一般就是给服务器环境上面配置一个钩子，这样就可以用钩子去推送，达到更新博客的目的。 自建钩子教程复杂，我为了方便就简单弄了一个宝塔+xftp上传 因为hexo g之后 生成的文件都是public目录下，每次生成之后利用xftp覆盖上传到宝塔目录，实现更新。 这种适合平时不怎么写文章，偶尔更新的博主。 最终效果 卷二兔也提供了非常多的搭建方法，我的建议是多看视频，文档有时候确实不好理解。 另外，我会把我遇到的问题都总结了一下，也可以留言给我遇到的问题 关于 hexo 配置汇总","categories":[{"name":"代码学习","slug":"Codelearning","permalink":"http://blog.aiheadn.cn/categories/Codelearning/"},{"name":"hexo","slug":"Codelearning/hexo","permalink":"http://blog.aiheadn.cn/categories/Codelearning/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://blog.aiheadn.cn/tags/hexo/"},{"name":"博客","slug":"blog","permalink":"http://blog.aiheadn.cn/tags/blog/"},{"name":"Butterfly","slug":"Butterfly","permalink":"http://blog.aiheadn.cn/tags/Butterfly/"}]},{"title":"java+swing+mysql 实现简单的班级管理系统","slug":"java-swing-mysql-实现简单的班级管理系统","date":"2023-01-03T14:56:18.000Z","updated":"2023-01-04T06:03:07.564Z","comments":true,"path":"archives/4f6b19d6.html","link":"","permalink":"http://blog.aiheadn.cn/archives/4f6b19d6.html","excerpt":"","text":"链接：https://pan.baidu.com/s/13S39GLMJHMpzySX5XB1mHQ提取码：n94a","categories":[{"name":"代码学习","slug":"Codelearning","permalink":"http://blog.aiheadn.cn/categories/Codelearning/"},{"name":"Java","slug":"Codelearning/Java","permalink":"http://blog.aiheadn.cn/categories/Codelearning/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.aiheadn.cn/tags/Java/"}]},{"title":"总结平面设计的学校宣传作品","slug":"总结2022年部分设计的学校宣传作品","date":"2023-01-03T14:54:19.000Z","updated":"2023-03-08T07:59:16.379Z","comments":true,"path":"archives/586e1f4c.html","link":"","permalink":"http://blog.aiheadn.cn/archives/586e1f4c.html","excerpt":"","text":"","categories":[{"name":"平面设计","slug":"plane","permalink":"http://blog.aiheadn.cn/categories/plane/"}],"tags":[{"name":"海报","slug":"海报","permalink":"http://blog.aiheadn.cn/tags/%E6%B5%B7%E6%8A%A5/"}]},{"title":"2021大学生计算机设计大赛作品","slug":"2021大学生计算机设计大赛作品","date":"2023-01-03T14:37:42.000Z","updated":"2023-01-06T06:35:10.289Z","comments":true,"path":"archives/6bb180e7.html","link":"","permalink":"http://blog.aiheadn.cn/archives/6bb180e7.html","excerpt":"","text":"感言关于这次比赛，让我对ps有了更加深刻的了解。 关于软件使用：Adobe Photoshop CC 2019 Adobe Illustrator 2019素材来源：千库网 包图网内存总量：300MB团队成员： 李烘光 高震铄 田志宇所获奖项: 二等奖证书编号：JSJDS202100462021041482000276807771查询地址：https://2021.jsjds.com.cn/Index/main/certification-verification备份链接：链接：https://pan.baidu.com/s/1K5ZadHp19rkpTZR3AXZ--A 以下为预览图","categories":[{"name":"平面设计","slug":"plane","permalink":"http://blog.aiheadn.cn/categories/plane/"}],"tags":[{"name":"平面设计","slug":"plane","permalink":"http://blog.aiheadn.cn/tags/plane/"},{"name":"PS","slug":"PS","permalink":"http://blog.aiheadn.cn/tags/PS/"},{"name":"作品","slug":"zuopin","permalink":"http://blog.aiheadn.cn/tags/zuopin/"},{"name":"比赛","slug":"bisai","permalink":"http://blog.aiheadn.cn/tags/bisai/"}]},{"title":"应用腾讯cos总结及COSBrowser 工具","slug":"应用腾讯cos总结及COSBrowser 工具","date":"2023-01-02T10:42:06.000Z","updated":"2023-01-04T06:03:07.572Z","comments":true,"path":"archives/c5a2465c.html","link":"","permalink":"http://blog.aiheadn.cn/archives/c5a2465c.html","excerpt":"","text":"什么是腾讯cos存储对象存储（Cloud Object Storage，COS）是由腾讯云推出的无目录层次结构、无数据格式限制，可容纳海量数据且支持 HTTP&#x2F;HTTPS 协议访问的分布式存储服务。腾讯云 COS 的存储桶空间无容量上限，无需分区管理，适用于 CDN 数据分发、数据万象处理或大数据计算与分析的数据湖等多种场景。COS 提供网页端管理界面、多种主流开发语言的 SDK、API 以及命令行和图形化工具，并且兼容 S3 的 API 接口，方便用户直接使用社区工具和插件。前面的话取自于官方 用它可以干什么1.cos最大特点在于存储大量的图片或数据2.易于生成外联方便调用3.搭配可视化的COSBrowser 工具完全可以当个人云盘使用（产生外网流量费用成本较高）4.便宜5.等待补充 应用目前应用于博客的主要图片存储，节省服务器空间成本 为什么使用腾讯cos他可以当成一个天然的图床使用 而且安全系数高 图片不容易丢失如果将大量的图片存放在免费图床 代表着图床一旦关闭 图片外链会全部失效（最昂贵的就是免费）另外将图片部署在服务器也会影响页面等待加载速度 页面可能出现卡死 丢帧 反应速度慢。使用外链大幅度提升页面响应速度 COSBrowserCOSBrowser 是腾讯云对象存储 COS 推出的可视化界面工具，让您可以使用更简单的交互轻松实现对 COS 资源的查看、传输和管理。目前 COSBrowser 有桌面端和移动端两种，详情可参见： 桌面端使用说明移动端使用说明 COSBrowser 工具下载[tabs][tab name&#x3D;”桌面端” active&#x3D;”true”] Windows Windows 7 32&#x2F;64位以上、Windows Server 2008 R2 64位以上 macOS macOS 10.13以上 Linux 需带有图形界面并支持 AppImage 格式注意：CentOS 启动客户端需在终端执行 .&#x2F;cosbrowser.AppImage –no-sandbox [&#x2F;tab][tab name&#x3D;”移动端”]Android Android 4.4以上iOS iOS 11以上[&#x2F;tab][tab name&#x3D;”网页端”]Web Chrome&#x2F;FireFox&#x2F;Safari&#x2F;IE10+等浏览器[&#x2F;tab][&#x2F;tabs]","categories":[{"name":"信息技术","slug":"xingxijishu","permalink":"http://blog.aiheadn.cn/categories/xingxijishu/"}],"tags":[{"name":"腾讯cos","slug":"cos","permalink":"http://blog.aiheadn.cn/tags/cos/"}]}],"categories":[{"name":"代码学习","slug":"Codelearning","permalink":"http://blog.aiheadn.cn/categories/Codelearning/"},{"name":"框架学习","slug":"Codelearning/kuangjia","permalink":"http://blog.aiheadn.cn/categories/Codelearning/kuangjia/"},{"name":"信息技术","slug":"xingxijishu","permalink":"http://blog.aiheadn.cn/categories/xingxijishu/"},{"name":"Java","slug":"Codelearning/Java","permalink":"http://blog.aiheadn.cn/categories/Codelearning/Java/"},{"name":"文档","slug":"Codelearning/doc","permalink":"http://blog.aiheadn.cn/categories/Codelearning/doc/"},{"name":"hexo","slug":"Codelearning/hexo","permalink":"http://blog.aiheadn.cn/categories/Codelearning/hexo/"},{"name":"linux","slug":"Codelearning/linux","permalink":"http://blog.aiheadn.cn/categories/Codelearning/linux/"},{"name":"平面设计","slug":"plane","permalink":"http://blog.aiheadn.cn/categories/plane/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://blog.aiheadn.cn/tags/spring/"},{"name":"vue","slug":"vue","permalink":"http://blog.aiheadn.cn/tags/vue/"},{"name":"edu","slug":"edu","permalink":"http://blog.aiheadn.cn/tags/edu/"},{"name":"C","slug":"C","permalink":"http://blog.aiheadn.cn/tags/C/"},{"name":"Java","slug":"Java","permalink":"http://blog.aiheadn.cn/tags/Java/"},{"name":"cmd","slug":"cmd","permalink":"http://blog.aiheadn.cn/tags/cmd/"},{"name":"文档","slug":"doc","permalink":"http://blog.aiheadn.cn/tags/doc/"},{"name":"网站","slug":"web","permalink":"http://blog.aiheadn.cn/tags/web/"},{"name":"hexo","slug":"hexo","permalink":"http://blog.aiheadn.cn/tags/hexo/"},{"name":"linux","slug":"linux","permalink":"http://blog.aiheadn.cn/tags/linux/"},{"name":"node","slug":"node","permalink":"http://blog.aiheadn.cn/tags/node/"},{"name":"npm","slug":"npm","permalink":"http://blog.aiheadn.cn/tags/npm/"},{"name":"博客","slug":"blog","permalink":"http://blog.aiheadn.cn/tags/blog/"},{"name":"Butterfly","slug":"Butterfly","permalink":"http://blog.aiheadn.cn/tags/Butterfly/"},{"name":"海报","slug":"海报","permalink":"http://blog.aiheadn.cn/tags/%E6%B5%B7%E6%8A%A5/"},{"name":"平面设计","slug":"plane","permalink":"http://blog.aiheadn.cn/tags/plane/"},{"name":"PS","slug":"PS","permalink":"http://blog.aiheadn.cn/tags/PS/"},{"name":"作品","slug":"zuopin","permalink":"http://blog.aiheadn.cn/tags/zuopin/"},{"name":"比赛","slug":"bisai","permalink":"http://blog.aiheadn.cn/tags/bisai/"},{"name":"腾讯cos","slug":"cos","permalink":"http://blog.aiheadn.cn/tags/cos/"}]}